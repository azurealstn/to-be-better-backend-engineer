# [Book] SQL 첫걸음

이번에 정리할 책은 [SQL 첫걸음](https://www.yes24.com/Product/Goods/22744867)이라는 책이다. 데이터베이스를 처음 배운다면 이 책을 추천한다.

## 목차

- [데이터베이스](#데이터베이스)
- [DBMS](#dbms)
- [다양한 데이터베이스](#다양한-데이터베이스)
- [RDBMS 사용 시스템](#rdbms-사용-시스템)
- [SQL의 방언과 표준화](#sql의-방언과-표준화)
- [데이터베이스 서버](#데이터베이스-서버)
- [예약어와 DB 객체명](#예약어와-db-객체명)
- [테이블](#테이블)
- [검색](#검색)
- [정렬](#정렬)
- [결과 행 제한하기 - LIMIT](#결과-행-제한하기---limit)
- [수치연산](#수치연산)
- [INSERT](#insert)
- [물리삭제와 논리삭제](#물리삭제와-논리삭제)
- [집계함수](#집계함수)
- [그룹화 - GROUP BY](#그룹화---group-by)
- [서브쿼리](#서브쿼리)
- [EXISTS](#exists)
- [데이터베이스 객체](#데이터베이스-객체)
- [인덱스](#인덱스)
- [뷰](#뷰)

## 데이터베이스

데이터란 컴퓨터 안에 기록되어 있는 숫자를 의미하며, 이러한 데이터의 집합을 데이터베이스라고 한다. 넓은 의미에서는 컴퓨터 안에 기록된 모든 것이라 할 수 있는데 여기서 말하는 데이터베이스는 특정 데이터를 확인하고 싶을 때 간단하게 찾아낼 수 있도록 정리된 형태를 가리킨다.

주기억장치에 데이터를 저장한다면 휘발성이므로 전원을 끄면 모든 데이터가 사라진다. 데이터베이스 내의 데이터는 영구적으로 보존되어야하므로 하드디스크나 플래시메모리(SSD) 등 비휘발성 저장장치에 저장한다.

### 시스템 내의 데이터베이스

현재는 데이터베이스가 개인용 컴퓨터나 휴대용 기기에 내장되어 있기도 한다.

- 웹 시스템과 데이터베이스
- POS 시스템과 데이터베이스
- 휴대전화의 데이터베이스

> 데이터베이스는 다양한 시스템에서 사용한다.

## DBMS

데이터베이스 즉 DB는 저장장치 내에 정리되어 저장된 데이터의 집합이고, 이를 효율적으로 관리하는 소프트웨어를 데이터베이스 관리 시스템(Database Management System), 약자로 DBMS라 부른다.

### DBMS가 필요한 이유

- 생산성: 어떤 시스템에서든 데이터 검색, 추가, 삭제, 갱신과 같은 처리가 이루어지는데 이러한 기본 기능을 DBMS가 제공한다.
- 기능성: DBMS는 DB를 다루는 기능을 많이 제공한다. 복수 유저의 요청에 대응, 대용량 데이터 저장 및 고속 검색 지원 더 나아가 DB 관리 기능을 유저가 확장할 수도 이어 유연하게 시스템을 개발할 수 있다.
- 신뢰성: 대규모 DB는 많은 요청에 대응할 수 있도록 만들어져 있다. 이를 위해 하드웨어를 여러 대로 구성하여 신뢰성 향상과 성능이 향상되고, 일부 DBMS는 컴퓨터 여러 대를 두고, 소프트웨어를 통해 확장성과 부하 분산을 구현한다. 이를 보통 클러스터 구성 또는 스케일 아웃이라 부른다.

또한 많은 DBMS가 DB의 데이터를 다른 저장장치로 내보내거나 DB 안에 데이터를 집어넣는 등의 기능을 지원한다. 이를 통해 DB를 간단하게 백업할 수도 있다.

> DBMS란 DB를 관리하는 소프트웨어로, 사용 목적은 생산성 향상과 가능성, 신뢰성 확보에 있다.

### DB를 조작하는 언어 SQL

DBMS를 이용하면 DB를 참조할 수 있고 데이터를 추가하거나 삭제, 갱신할 수 있는데 이처럼 DBMS와의 대화에 필요한 것이 SQL이다. SQL은 관계형 데이터베이스 관리 시스템(RDBMS: Relational Database Management System)을 조작할 때 사용한다.

SQL은 IBM이 개발한 SEQUEL이라는 관계형 데이터베이스 조작용 언어를 기반으로 만들어졌다. 현재 ISO 등에 의해 표준화가 진행되었다.

> SQL은 관계형 DB에서 사용한다.

### SQL명령의 종류는 크게 3가지

- DML: Data Manipulation Language의 약자. DB에 새롭게 데이터를 추가하거나 삭제, 갱신하는 등 데이터를 조작할 때 사용한다. SQL의 가장 기본이 되는 명령셋(set)이다.
- DDL: Data Definition Language의 약자. DB는 DB Object라는 데이터 그릇을 이용하여 데이터를 관리하는데, 이 같은 객체를 만들거나 삭제하는 명령어이다.
- DCL: Data Control Language의 약자. 데이터를 제어하는 명령어이다. DCL에는 트랜잭션을 제어하는 명령과 데이터 접근권한을 제어하는 명령이 포함되어 있다.

> SQL 명령은 DML, DDL, DCL의 세 종류로 나뉜다.

## 다양한 데이터베이스

-DBMS는 데이터 저장 방법에 따라 몇 가지로 분류할 수 있다.

### 계층형 데이터베이스

역사가 오래된 DBMS로, 폴더와 파일 등의 계층 구조로 데이터를 저장하는 방식의 데이터베이스다. 하드디스크나 DVD 파일시스템을 계층형 데이터베이스라고 할 수 있다. 하지만 현재 DBMS로서 채택되는 경우가 많지 않다.

### 관계형 데이터베이스

관계 대수라는 것에 착안하여 고안한 데이터베이스이다. 관계 대수란 행과 열을 가지는 표형식 데이터를 저장하는 형태의 데이터베이스를 가리킨다.

### 객체지향 데이터베이스

가능하면 객체 그대로를 데이터베이스의 데이터로 저장하는 것이 객체지향 데이터베이스이라 한다.

### XML 데이터베이스

XML 형식으로 기록된 데이터를 저장하는 데이터베이스이다. XML 데이터베이스에는 SQL 명령을 사용할 수 없다. 대신ㄴ XML 데이터를 검색할 때는 XQuery라는 명령어를 사용한다.

### 키-밸류 스토어 (KVS)

키와 그에 대응하는 값이라는 단순한 형태의 데이터를 저장하는 데이터베이스이다. NoSQL이라는 슬로건으로부터 생겨난 데이터베이스로 열 지향 데이터베이스라고도 불린다.

## RDBMS 사용 시스템

- 메인 프레인: 다운사이징으로인해 소형 워크스테이션으로 대체
- 대형 범용기기
- 웹 시스템과 RDBMS
- 안드로이드에 포함된 SQLite: 휴대단말 등 작은 하드웨어용으로 경량화한, 임베디드 시스템에 자주 쓰이는 RDBMS다.

### RDBMS 종류

- Oracle
- DB2
- SQL server
- PostgreSQL
- MySQL
- MariaDB
- SQLite

## SQL의 방언과 표준화

RDBMS는 처음부터 SQL 명령어를 이용해 DB를 조작하도록 설계된만큼, SQL을 사용할 수 없는 RDBMS는 없다. 하지만 각 DB 제품별로 기능 확장이 이루어지는 과정에서 SQL을 사용하는 명령어가 달랐는데 이를 고유 방언이라고 부른다. 즉, 원리는 같지만 SQL 사용하는 방법이 제각각 조금씩 다르다는 의미다.

> SQL에는 방언이 있다. 방언 대신 표준 SQL을 사용하는 편이 좋다.

## 데이터베이스 서버

많은 RDBMS가 클라이언트/서버 모델을 채택해 가동중이다. 특히 웹시스템과 연동하는 RDBMS라면 접속자 수가 수백, 수천명에 달하는 전용 DB 서버를 운용하는 일도 드물지 않다.

RDBMS는 복수의 클라이언트가 보내오는 요청에 응답할 수 있도록 클라이언트/서버 모델로 동작한다.

### 클라이언트/서버 모델

클라이언트/서버 모델이란 사용자 조작에 따라 요청을 전달하는 클라이언트와 해당 요청을 받아 처리하는 서버로 소프트웨어를 나누고, 복수의 컴퓨터 상에서 하나의 모델을 구현하는 시스템을 말한다.

RDBMS는 사용자 별로 DB 접근을 제한할 수 있다. 이 때문에 DB를 사용하기 위해서는 사용자 인증을 거쳐야 한다. 사용자 인증은 ID, PW로 실행되고, 인증 실패시 DB에 접속할 수 없다.

> DB를 사용할 때는 ID와 PW를 이용한 사용자 인증이 필요하다.

실제로 DB에 접속하는 것은 PHP나 루비 등의 프로그래밍 언어로 만들어진 CGI 프로그램이다. DB 서버를 사용하기 위해서는 먼저 DB 서버와의 접속이 성립되어야 하며, 그 후 DB에 필요한 SQL 명령을 전달하고, 실행결과는 클라이언트로 되돌아간다. 이 때 웹 서버의 CGI 프로그램이 DB의 클라이언트가 된다.

실제로 대규모 시스템에서는 웹 서버나 DB 서버를 여러 대로 구성하여 운용하는 경우도 많다.

> 클라이언트/서버 모델은 유여한 하드웨어 구성을 실현한다.

## 예약어와 DB 객체명

SELECT와 FROM 같은 키워드가 예약어이다. DB에는 테이블 외에 다양한 데이터를 저장하거나 관리하는 어떤 것을 만들 수 있는데 이것을 DB 객체라 부른다. 예를 들면 뷰(VIEW)가 이에 해당한다. 또한 DB 객체의 이름은 서로 중복될 수 없다는 점과 예약어를 DB 객체의 이름으로 사용할 수 없다는 점을 유의하자.

> DB 객체는 테이블 또는 뷰에 해당한다.

예약어와 DB 객체명은 대소문자를 구별하지 않는다. 다만 회사마다 대문자로 사용하는 것을 통일할 수 있고 또는 소문자로만 사용하는 것으로 정의할 수도 있다.

## 테이블

![table-1](/book/sql-first-step/images/table-1.png)
(사진 출처: https://hongong.hanbit.co.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-databasedb-dbms-sql%EC%9D%98-%EA%B0%9C%EB%85%90/)

표 형식의 데이터를 테이블이라 부르고 행(레코드)과 열(컬럼/필드)로 구성된다. 행은 모두 동일한 형태로 되어 있으며 옆으로 열(컬럼/필드)이 나열되는데 열마다 이름이 지정되어 있다. 각각의 행과 열이 만나는 부분을 셀 이라고 부른다. 셀에는 하나의 데이터 값이 저장되어 있다.

> 하나의 셀: 화사, 솔라, flower 등등..

또한 데이터는 자료형으로 분류할 수 있다. 열은 하나의 자료형만 가질 수 있다. 예를 들면, 숫자만으로 구성된 데이터를 수치형 데이터, 문자열로 구성된 데이터를 문자열형 데이터, 날짜와 시각을 나타내는 날짜시간형 데이터 등이 있다.

### NULL

값이 없는 데이터를 NULL이라 한다. NULL은 데이터가 들어있지 않은 것을 의미하는 특별한 값이다.

### DESC

```sql
DESC sample21;
```

DESC 명령어를 사용하면 테이블에 어떤 열이 정의되어 있는지, 어떤 자료형인지, NULL을 허용하는지, 키 값이 무엇인지, 디폴트 값이 있는지 등 전체정보를 알 수 있다. (참고로 DESC는 SQL 명령어가 아니다.)

> DESC 명령으로 테이블 구조를 참조할 수 있다.

### 자료형

전에 테이블에는 자료형이 있다 했다.

- INTEGER: 정수값을 저장할 수 있는 자료형
- CHAR: 문자열을 저장할 수 있는 자료형
- VARCHAR: 문자열을 저장할 수 있는 자료형
- DATE: 날짜값을 저장할 수 있는 자료형
- TIME: 시간을 저장할 수 있는 자료형

### CHAR VS VARCHAR

CHAR형은 언제나 고정된 길이로 데이터가 저장된다. 그에 따라 고정 길이 문자열 자료형이라고 한다. CHAR형에서는 길이가 고정되기 때문에 최대 길이보다 작은 문자열을 저장할 경우 공백문자로 나머지를 채운 후 저장하게 된다.

반면에 VARCHAR형은 저장할 문자열의 길이에 맞춰 저장공간을 가변적으로 사용하여 저장한다. 그에 따라 가변 길이 문자열 자료형이라고도 한다. 이렇게만 보면 실무에서는 거의 VARCHAR 사용이 불가피한 선택인 것 같다.

이외에도 많은 자료형이 있으니 구글에 검색해보자.

## 검색

- A.NAME = B.NAME : 같은지 비교
- A.PRICE > B.PRICE : 누가 더 큰지, 작은지 비교
  - A.PRICE < B.PRICE
  - A.PRICE >= B.PRICE
  - A.PRICE <= B.PRICE
- A.PRICE <> B.PRICE : 다른지 비교, 다른 경우 TRUE
- IS NULL : NULL인 경우만 검색
- AND : 모든 조건 만족시
- OR : 하나의 조건이라도 만족시
- NOT : 조건의 부정
- LIKE : 패턴 검색

### 이스케이프

- `%%%` 처럼 %를 포함한 문자열을 검색하려면 `%\%%` 처럼 앞에 `\`를 붙여야 한다.
- 마찬가지로 `It's`를 검색한다고 했을 때 `'It's'` 이와 같이 검색하는 것이 아니라 `'It''s'` 이와 같이 `'`를 2개 연속해서 사용한다.
- 간단한 패턴 매칭이라면 LIKE로 충분하다만 더 복잡한 패턴을 매칭하는 경우는 정규 표현식(Regular Expression)을 사용하는 편이 더 낫다. 또한 최근에는 대부분의 DB가 정규표현식을 지원한다.

## 정렬

```sql
ORDER BY ROW_NO DESC
```

ORDER BY 키워드를 사용하여 리스트를 정렬할 수 있다. 다만 정렬시 주의할 점이 있다.

| A   | B   |
| --- | --- |
| 1   | 1   |
| 2   | 2   |
| 10  | 10  |
| 11  | 11  |

위 테이블에서 A열은 문자열(VARCHAR)이고, B열은 수치형(INTEGER)이다.

```sql
SELECT * FROM SAMPLE311 ORDER BY A
```

| A   | B   |
| --- | --- |
| 1   | 1   |
| 10  | 10  |
| 11  | 11  |
| 2   | 2   |

위 명령어를 실행하면 위와 같은 표로 보여준다. A열에서 1 다음에 2가 나올줄 알았지만 10이 나온 것이다. 그 이유는 A열은 문자열(VARCHAR)이고 문자열은 대소관계를 사전식 순서로 비교했기 때문에 이러한 상황이 발생한다.

```sql
SELECT * FROM SAMPLE311 ORDER BY B
```

만약 위와 같이 B로 정렬했다면 정상적으로 보여주었을 것이다. 그 이유는 B열은 수치형(INTEGER)이기 때문이다.

ORDER BY는 테이블에 영향을 주지 않는다. ORDER BY를 이용해 행 순서를 바꿀 수 있을뿐 저장장치에 저장된 데이터의 행 순서를 변경하는 것은 아니다. SELECT 명령은 데이터를 검색하는 명령이다. 이는 테이블의 데이터를 참조만 할 뿐이며 변경은 하지 않는다.

### 복수의 열을 지정해 정렬하기

```sql
SELECT 열명 FROM 테이블명 ORDER BY 열명1, 열명2...
```

### NULL 값의 정렬순서

NULL은 데이터가 들어있지 않은 것을 의미하는 특별한 값이라고 했다. 특성상 대소비교를 할 수 없어 정렬 시에는 별도의 방법으로 취급한다.

ORDER BY로 지정한 열에서 NULL값을 가지는 행은 가장 먼저 표시되거나 가장 나중에 표시된다. NULL에 대한 대소비교 방법은 표준 SQL에도 규정되어 있지 않아 DB 제품에 따라 기준이 다르다.

MySQL의 경우 NULL값을 가장 작은 값으로 취급해 ASC(오름차순)에서는 가장 먼저, DESC(내림차순)에서는 가장 나중에 표시된다.

## 결과 행 제한하기 - LIMIT

```sql
SELECT 열명 FROM 테이블명 LIMIT 행수 [OFFSET 시작행]
```

웹에서 정말 많이 사용되는 페이징 구현할 때 주로 사용한다. 리스트가 몇백, 몇천, 몇만씩 된다면 모든 리스트를 가져오면 쿼리 시간이 증가한다. 이때 리스트수를 제한하기 위해 LIMIT과 OFFSET 키워드를 사용한다.

```sql
SELECT 열명 FROM 테이블명 WHERE 조건식 ORDER BY 열명 LIMIT 행수
```

- LIMIT 키워드는 가장 마지막에 쓴다.
- 정렬한 후 제한하기
  - `LIMIT 3`보다 `WHERE NO <=3`처럼 조건식을 사용해도 동일한 경과를 얻을 수 있다.
  - 다만 LIMIT과 WHERE은 기능과 내부처리 순서가 전혀 다르다.
  - LIMIT은 반환할 행수를 제한하는 기능으로, WHERE 구로 검색한 후 ORDER BY로 정렬된 뒤 최종적으로 처리된다.
- LIMIT를 사용할 수 없는 DB에서의 행 제한
  - 참고로 LIMIT은 표준 SQL이 아니기 때문에 MySQL과 PostgreSQL에서만 사용할 수 있다. 그 이외의 DBMS에서는 관련 키워드로 구글에 검색하면 확인할 수 있다.

## 수치연산

- SQL을 사용하면 사칙연산이 가능하다.
  - `+`: 덧셈
  - `-`: 뺄셈
  - `*`: 곱셈
  - `/`: 나눗셈
  - `%`: 나머지

```sql
SELECT *, price * quantity AS amount FROM SAMPLE34;
```

- 키워드 AS는 생략할 수 있다.
- 엘리어스(alias)라고도 불리는 별명은 영어, 숫자, 한글 등으로 지정할 수 있다. 단, 별명을 한글로 지정하는 경우에는 여러가지로 오작하는 경우가 많으므로 되도록 영어를 사용하자.
- 이름 지정하는 경우 숫자로 시작되지 않도록 하자.
- SELECT 구에서 지정한 별명은 WHERE 구 안에서 사용할 수 없다.
  - 표준 SQL에는 내부처리 순서가 따로 정해져 있지 않지만 대부분 WHERE -> SELECT 순서로 내부 처리를 하기 때문이다.
- NULL값에 사칙연산을 하면 NULL이 된다.
  - 하지만 나눗셈의 경우 아에 에러가 발생하니 주의하자.

> alias 이름에 한글 즉, ASCII 문자 이외의 것을 포함할 경우는 더블쿼트로 둘러싸서 지정한다.

## INSERT

행을 추가할 때 유효한 값이 없는 상태(NULL)로 두고 싶을 경우에는 VALUES 구에서 NULL로 값을 지정할 수 있다. 만약 컬럼에 NOT NULL 제약이 걸려있다면 에러가 발생한다.

DESC 명령으로 열 구성을 살펴보면 Default라는 항목을 찾을 수 있다. Default는 명시적으로 값을 지정하지 않았을 경우 사용하는 초기값을 말한다. Default 값은 테이블을 정의할 때 지정할 수 있고, 열을 지정해 행을 추가할 때 지정하지 않은 열은 Default 값을 사용하여 저장된다.

### INSERT SELECT

```sql
INSERT INTO SAMPLE SELECT 1, 2;

INSERT INTO SAMPLE SELECT * FROM SAMPLE;
```

SELECT로 조회한 데이터를 그대로 INSERT하는 방식이다. 실무에서도 사용하므로 알아두면 좋다. 여기서 주의점은 SELECT 명령이 반환하는 값이 꼭 스칼라 값일 필요는 없으며, SELECT가 반환하는 열 수와 자료형이 INSERT할 테이블과 일치하기만 하면 된다.

## 물리삭제와 논리삭제

DB에서 데이터를 삭제하는 방법은 용도에 따라 크게 물리삭제와 논리삭제 두 가지로 나뉩니다. 이는 SQL 명령에 관한 내용이 아닌 시스템 설계 분야에 대한 내용이다.

먼저 물리삭제는 SQL의 DELETE 명령을 사용해 직접 데이터를 삭제하자는 사고 방식이다. 테이블에서 아에 물리적으로 삭제시킨다. 따라서 삭제한 부분은 더 이상 확인할 수 없다.

한편 논리삭제의 경우 테이블에 삭제플래그와 같은 열을 미리 준비해둡니다. 즉, 테이블에서 실제로 행을 삭제하는 대신, UPDATE 명령을 이용해 삭제플래그의 값을 유효하게 갱신해두자는 발상에 의한 삭제방법을 말한다.

논리삭제의 장점으로는 데이터를 실제로 삭제하지 않기 때문에 삭제되기 전의 상태로 간단히 되돌릴 수 있다는 것을 꼽을 수 있다.

논리삭제의 단점으로는 삭제해도 DB의 저장공간이 늘어나지 않는 점, 그리고 DB의 크기가 증가함에 따라 검색속도가 떨어지는 점이 있다. 또한 애플리케이션 측 프로그램에서는 삭제임에도 불구하고 UPDATE 명령을 실행하므로 혼란을 야기할 수 있다.

어떤 방법으로 삭제할 것인지는 시스템의 특성이나 테이블에 저장되어 있는 데이터의 특성에 따라 다르기 때문에 단정지어 말할 수는 없다. 상황에 맞게 선택해야 한다.

예를 들어, SNS 서비스처럼 사용자의 개인정보를 다루는 시스템에서는 사용자가 탈퇴한 경우 데이터를 삭제한다. 이 때 개인정보를 취급하는 마스터 테이블에서 삭제할 경우에는 물리삭제를 하는 편이 안전할 것이다. 개인정보의 유출을 미연에 방지하는 측면에서도 좋은 선택이라 할 수 있다.

반면 쇼핑 사이트의 경우 사용자가 주문을 취소할 경우에도 데이터를 삭제한다. 이러한 경우에는 논리삭제 방법을 많이 사용한다. 주문이 취소되었다고해도 발주는 된 것으로, 해당 정보가 완전히 불필요한 것이라고는 말할 수 없다. 이러한 데이터는 특히 주문 관련 통계를 낼 때 유용하게 사용할 수 있기 때문이다.

한편으로는 하드웨어의 제한으로 인해 물리삭제를 할 수밖에 없는 경우도 있을 것이다. 논리삭제로는 실제로 데이터가 삭제되지 않기 때문에 DB의 사용량은 줄어들지 않으며, 오히려 일방적으로 늘어난다. 이 때 저장공간이 작다면 가능한 한 용량이 모자라지 않도록 운용할 필요가 있다. 결국 물리삭제 방법으로 데이터를 지운다.

따라서 물리삭제와 논리삭제는 어느 쪽이 좋은지 따지기보다는 상황에 따라 용도에 맞게 데이터 삭제 방법을 선택하는 것이 중요하다.

## 집계함수

- COUNT: 행 개수를 구한다.
- SUM: 합계를 구한다.
- AVG: 평균을 구한다.
- MIN: 최소값을 구한다.
- MAX: 최대값을 구한다.

SQL은 DB라 불리는 데이터 집합을 다루는 언어이다. 이 같은 집합의 개수나 합계가 궁금하다면 SQL이 제공하는 집계함수를 사용하여 간단하게 구할 수 있다.

SQL은 집합을 다루는 집계함수를 제공한다. 일반적인 함수는 인수로 하나의 값을 지정하는데 비해 집계함수는 집합을 지정한다. 이 때문에 집합함수라고도 불린다. 즉, 집합을 특정 방법으로 계산하여 그 결과를 반환한다. 집계함수는 집합 안에 NULL 값이 있을 경우 무시한다. 집계함수에서 `DISTINCT`를 사용하면 중복을 제거할 수 있다.

## 그룹화 - GROUP BY

```sql
SELECT * FROM 테이블명 GROUP BY 열1, 열2, ...
```

GROUP BY 구에 열을 지정하여 그룹화하면 지정된 열의 값이 같은 행이 하나의 그룹으로 묶인다. GROUP BY를 지정해 그룹화하면 DISTINCT와 같이 중복을 제거하는 효과가 있다.

사실 GROUP BY 구를 지정하는 경우에는 집계함수와 함께 사용하지 않으면 별 의미가 없다. GROUP BY 구로 그룹환된 각각의 그룹이 하나의 집합으로서 집계함수의 인수로 넘겨지기 때문이다.

업무 환경에서 GROUP BY를 사용하는 경우는 꽤 많다. 예를 들면, 각 점포의 일별 매출 데이터가 중앙 판매 관리시스템에 전송되어 점포별 매출실적을 집계해 어떤 점포가 매출이 올라가는지, 어떤 상품이 인기가 있는지 등을 분석할 때 사용된다. 여기서 점포별, 상품별, 월별, 일별 등 특정 단위로 집계할 때 GROUP BY를 자주 사용한다.

### HAVING 구로 조건 지정

집계함수는 WHERE 구의 조건식에서는 사용할 수 없다. 그렇다면 집계한 결과에서 조건에 맞는 값을 따로 걸러낼 수는 없는 걸까? 물론 가능한데 `HAVING` 키워드를 사용하면 된다. HAVING 구를 사용하면 집계함수를 사용해서 조건식을 지정할 수 있다.

```sql
SELECT NAME, COUNT(NAME) FROM SAMPLE51 GROUP BY NAME HAVING COUNT(NAME) = 1;
```

집계함수를 사용할 경우에는 HAVING 구로 검색조건을 지정한다.

### 내부처리 순서

```sql
WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY
```

HAVING 구는 GROUP BY 구 다음으로 처리된다.

### 복수열의 그룹화

GROUP BY를 사용할 때 주의할 점이 하나 더 있다. GROUP BY에 지정한 열 이외의 열은 집계함수를 사용하지 않은 채 SELECT 구에 기술해서는 안된다.

```sql
SELECT NO, NAME, QUANTITY FROM SAMPLE51 GROUP BY NAME;
```

NAME은 GROUP BY에서 지정하므로 괜찮지만 NO와 QUANTITY는 지정할 수 없다. 따라서 위 쿼리문은 에러가 발생한다. 에러를 해결하려면 NO와 QUANTITY에 집계함수를 사용하면 된다.

```sql
SELECT MIN(NO), NAME, SUM(QUANTITY) FROM SAMPLE51 GROUP BY NAME;
```

## 서브쿼리

서브쿼리는 SELECT 명령에 의한 데이터 질의로, 상부가 아닌 하부의 부수적인 질의를 의미한다.

```sql
( SELECT 명령 )
```

### DELETE의 WHERE 구에서 서브쿼리 사용하기

```sql
DELETE FROM SAMPLE WHERE A = (SELECT MIN(A) FROM SAMPLE);
```

서브쿼리를 사용하면 위 쿼리문처럼 DELETE와 SELECT를 결합시킬 수 있다.

### 스칼라 값

여기서 주의할 점이 있다. 위 서브쿼리인 `(SELECT MIN(A) FROM SAMPLE)`의 조회의 값이 복수값이 되면 안된다는 것이다. 만약 복수값이 조회된다면 에러가 발생할 것이다. (당연하다..) 즉, 단일값이 나와야 한다는 것이다. SELECT 명령이 하나의 값만 반환하는 것을 스칼라 값을 반환한다 라고 한다.

스칼라 값을 반환하는 SELECT 명령을 특별 취급하는 이유는 서브쿼리로서 사용하기 쉽기 때문이다. 스칼라 값을 반환하는 서브쿼리를 특별히 스칼라 서브쿼리라 부르기도 한다.

```sql
SELECT
  (SELECT COUNT(*) FROM SAMPLE) AS SQ1,
  (SELECT COUNT(*) FROM SAMPLE2) AS SQ2
FROM DUAL;
```

위의 쿼리문은 스칼라 서브쿼리를 사용한 예시이다. 위에서 서브쿼리를 사용한 예시들을 봤는데 다양하게 서브쿼리를 활용할 수 있다.

- DELETE 구의 WHERE
- SELECT 구
- UPDATE 구의 SET
- FROM 구
- INSERT 구

SELECT 구나 SET 구에서는 스칼라 서브쿼리를 지정해야 하지만 FROM 구에 기술할 경우에는 스칼라 값을 반환하지 않아도 된다. 물론 스칼라 값이여도 상관 없다.

```sql
SELECT *
FROM (
  SELECT * FROM SAMPE
) AS SQ;
```

SELECT 명령 안에 SELECT 명령이 들어있는 듯 보인다. 이를 네스티드(NESTED) 구조 또는 중첩구조나 내포구조라 불린다.

## EXISTS

```sql
EXISTS (SELECT 명령)

UPDATE SAMPLE SET A = 'GOOD' WHERE EXISTS (
  SELECT * FROM SAMPLE52 WHERE NO2 = NO
);
```

`EXISTS` 키워드를 사용하면 서브쿼리가 반환하는 결과값이 있는지를 조사할 수 있다. 특히 EXISTS를 사용하는 경우에는 서브쿼리가 반드시 스칼라 값을 반환할 필요는 없다. EXISTS는 단지 반환된 행이 있는지를 확인해보고 값이 있으면 참, 없으면 거짓을 반환하므로 어떤 패턴이라도 상관없다. EXISTS를 사용하면 서브쿼리를 사용해 검색할 때 데이터가 존재하는지 아닌지 판별하기 위해 조건을 지정할 수 있겠다.

`NOT EXISTS`는 `EXISTS`의 부정(NOT)이다. 있으면 거짓, 없으면 참을 반환한다.

```sql
UPDATE SAMPLE SET A = 'GOOD' WHERE EXISTS (
  SELECT * FROM SAMPLE52 WHERE NO2 = NO
);
```

위 쿼리문을 다시 보자. UPDATE 구는 부모가 되고, WHERE 구에 괄호로 묶은 부분이 자식이 된다. 부모 명령에서는 SAMPLE를 갱신한다. 자식인 서브쿼리에서는 SAMPLE52 테이블의 NO2 열 값이 부모의 NO 열 값과 일치하는 행을 검색한다. 이처럼 부모 명령과 자식인 서브쿼리가 특정 관계를 맺는 것을 상관 서브쿼리라 부른다.

`NO2 = NO`에서 열 이름이 다르기 때문에 어느 테이블에서 가져온 열인지 판별할 수 있다. 하지만 `NO = NO`처럼 열 이름이 같다면 테이블명 즉, alias를 지정해주는 것이 좋다.

### IN

IN을 사용하면 집합 안의 값이 존재하는지를 조사할 수 있다. 값을 여러개 지정할 경우에 조건식이 깔끔해진다.

```sql
SELECT * FROM SAMPLE FROM NO IN (3, 5);
SELECT * FROM SAMPLE FROM NO IN (SELECT NO2 FROM SAMPLE52);
```

## 데이터베이스 객체

처음 RDBMS 소프트웨어를 설치하면 DB는 비어있는 상태이다. 여기에 테이블, 뷰, 인덱스, 프로시저 등의 DB 객체를 작성해 DB를 구축한다.

DB 객체란 테이블이나 뷰, 인덱스 등 DB 내에 정의하는 모든 것을 일컫는 말이다. 객체의 이름은 중요하다. 어떤 데이터가 저장되어 있는지 파악하는 기준이 되는 경우가 많으므로 의미 없는 번호 등으로 이름을 붙이지 않도록 한다.

### 스키마

DB 객체는 스키마라는 그릇 안에 만들어진다. 따라서 객체의 이름이 같아도 스키마가 서로 다르다면 상관없다. 이와 같은 특징 때문에 DB 객체는 스키마 객체라 불리기도 한다. 실제로 DB에 테이블을 작성해서 구축해나가는 작업을 스키마 설계라고 부르며 스키마는 SQL 명령의 DDL을 이용하여 정의한다.

MySQL에서는 `CREATE DATABASE` 명령으로 작성한 데이터베이스가 스키마가 된다. 테이블과 스키마는 무엇인가를 담는 그릇 역할을 한다는 점에서 비슷하다. 테이블 안에는 열을 정의할 수 있고 스키마 안에는 테이블을 정의할 수 있다. 각각의 그릇 안에서는 중복하지 않도록 이름을 지정한다. 이처럼 이름이 충돌하지 않도록 기능하는 그릇을 네임스페이스(namespace)라고 부르기도 한다.

> 스키마나 테이블은 네임스페이스라고도 한다.

### ALTER TABLE 주의

- 최대길이 연장
  - 대규모 DB에서는 데이터의 크기가 매우 커지는 경향이 있다. 문자열형의 경우 최대길이를 지정하는데, 이 최대길이를 ALTER TABLE로 늘릴 수 있다.
  - 반대로 최대길이를 줄일 수도 있는데, 이때는 여러가지 문제가 발생한다. 먼저 기존의 행에 존재하는 데이터의 길이보다 작게 지정할 수는 없다. 작게 지정하면 저장된 데이터의 일부가 잘려나가므로 에러가 발생한다. 또한 열의 최대길이를 줄였다고 해서 실제 저장공간이 늘어나는 경우도 적다.
- 열 추가
  - 테이블에 열을 추가하는 일은 자주 일어난다. 적어도, 변경한 테이블에 행을 추가하는 INSERT 명령은 확인해야 한다. 열을 추가하면 해당 열에 대해 데이터 값을 지정해야 하기 때문이다.

### 복수의 열로 기본키 구성하기

기본키를 구성하는 열은 복수라도 상관없다. 복수의 열을 기본키로 지정했을 경우, 키를 구성하는 모든 열을 사용해서 중복하는 값이 있는지 없는지를 검사한다.

## 인덱스

색인이라고도 불리는 인덱스는 DB 객체 중 하나이다. 인덱스는 테이블에 붙여진 색인이라 할 수 있다. 인덱스의 역할은 검색속도의 향상이다. 여기서 검색이란 SELECT 명령에 WHERE 구로 조건을 지정하고 그에 일치하는 행을 찾는 일련의 과정을 말한다. 테이블에 인덱스가 지정되어 있으면 효율적으로 검색할 수 있으므로 WHERE로 조건이 지정된 SELECT 명령의 처리 속도가 향상된다.

인덱스는 테이블과는 별개로 독립된 DB 객체로 작성된다. 하지만 인덱스만으로는 아무런 의미가 없다. 목차밖에 없는 책은 본 적이 없는 것처럼, 인덱스는 테이블에 의존하는 객체라 할 수 있다. 대부분의 DB에서는 테이블을 삭제하면 인덱스도 같이 삭제된다.

### 검색에 사용하는 알고리즘

인덱스를 사용하면 효율적으로 검색할 수 있는 이유가 뭘까?

DB의 인덱스에 쓰이는 대표적인 검색 알고리즘으로는 이진 트리(binary tree)가 있으며, 그 다음으로 해시가 유명하다.

### 풀 테이블 스캔 (full table scan)

인덱스가 지정되지 않은 테이블을 검색할 때는 풀 테이블 스캔이라 불리는 검색 방법을 사용한다. 테이블에 저장된 모든 값을 처음부터 차례로 조사해나가는 것이다. 예를 들면, 행이 1,000건 있다면 최대 1,000번 값을 비교하는 것이다.

### 이진 탐색 (binary search)

이진 탐색은 차례로 나열된 집합에 대해 유효한 검색 방법이다. (이진 탐색이 무엇인지는 구글에 검색해 보길..)  
대부분 DB에서 기본키 제약은 인덱스를 갖고 있다.

### 인덱스 생성, 삭제

```sql
CREATE INDEX 인덱스명 ON 테이블명 (열명1, 열명2, ...)

DROP INDEX 인덱스명 -- 스키마 객체의 경우
DROP INDEX 인덱스명 ON 테이블명 -- 테이블 내 객체의 경우
```

### EXPLAIN

인덱스 작성을 통해 쿼리의 성능 향상을 기대할 수 있다. 이 때 실제로 인덱스를 사용해 검색하는지를 확인하려면 EXPLAIN 명령을 사용한다.

```sql
EXPLAIN SQL명령
```

### 최적화

내부 처리에서는 SELECT 명령을 실행하기에 앞서 실행계획을 세운다. 실행계획에서는 인덱스가 지정된 열이 WHERE 조건으로 지정되어 있으니 인덱스를 사용하자와 같은 처리가 이루어진다. EXPLAIN 명령은 이 실행계획을 확인하는 명령이다.

실행계획에서는 인덱스의 유무뿐만 아니라 인덱스를 사용할 것인지 여부에 대해서도 DB 내부의 최적화 처리를 통해 판단한다.

## 뷰

뷰는 테이블과 같은 부류의 DB 객체 중 하나이다.

DB 객체로 등록할 수 없는 SELECT 명령을, 객체로서 이름을 붙여 관리할 수 있도록 한 것이 바로 뷰이다. 뷰를 참조하면 그에 정의된 SELECT 명령의 실행결과를 테이블처럼 사용할 수 있다. 자주 사요하거나 복잡한 SELECT 명령을 뷰로 만들어 편리하게 사용할 수 있다.

뷰는 테이블처럼 취급할 수 있지만 실체가 존재하지 않는다라는 의미로 가상 테이블이라 불리기도 한다. 뷰는 테이블처럼 데이터를 쓰거나 지울 수 있는 저장공간을 가지지 않는다. 이 때문에 테이블처럼 취급할 수 있다고는 해도 SELECT 명령에서만 사용하는 것을 권장한다.

> 뷰는 SELECT 명령을 기록하는 DB 객체다.

### 뷰의 생성, 삭제

```sql
CREATE VIEW 뷰명 (열명1, 열명2, ...) AS SELECT 명령

DROP VIEW 뷰명
```

### 뷰의 약점

뷰는 DB 객체로서 저장장치에 저장된다. DB에 저장되는 것은 SELECT 명령뿐이기 때문에 테이블보다는 대량의 저장공간이 필요하지 않는다. 다만 검색뿐만 아니라 ORDER BY로 정렬하거나 GROUP BY로 집계하는 처리는 계산능력을 필요로 하기 때문에 CPU 자원을 사용한다.

### 머티리얼라이즈드 뷰(Materialized View)

뷰의 근원이 되는 테이블에 보관하는 데이터양이 많은 경우, 집계처리를 할 때도 뷰가 사용된다면 처리속도가 많이 떨어질 수밖에 없다. 뷰를 중첩해서 사용하는 경우에도 처리속도가 떨어진다.

이 같은 상황을 피하기 위해 사용할 수 있는 것이 Materialized View이다.  
일반적인 뷰는 데이터를 일시적으로 저장했다가 쿼리가 실행 종료될 때 함께 삭제된다. 그에 비해 Materialized View는 데이터를 일시적으로 저장해 사용하는 것이 아니라 테이블처럼 저장장치에 저장해두고 사용한다.

Materialized View는 처음 참조되었을 때 데이터를 저장해둔다. 이후 다시 참조할 때 이전에 저장해두었던 데이터를 그대로 사용한다. 일반적인 뷰처럼 매번 SELECT 명령을 실행할 필요가 없다. 다만 뷰에 지정된 테이블의 데이터가 변경된 경우에는 SELECT 명령을 재실행하여 데이터를 다시 저장한다.

따라서 뷰에 저장된 테이블의 데이터가 자주 변경되지 않는 경우라면 Materialized View를 사용하여 뷰의 약점을 어느정도 보완할 수 있다.

### 함수 테이블

뷰의 약점을 보완하는 또다른 방법은 함수 테이블을 사용하는 것이다. 함수 테이블은 테이블을 결과값으로 반환해주는 사용자정의 함수이다. 함수에는 인수를 지정할 수 있기 때문에 인수의 값에 따라 WHERE 조건을 붙여 결과값을 바꿀 수 있다. 그에 따라 상관 서브쿼리처럼 동작할 수 있다.

## 집합 연산

이전까지 배운 SQL 명령은 대부분 하나의 테이블을 사용하는 것이다. 이번에는 복수의 테이블을 사용해 데이터를 검색하는 방법을 알아보자.

RDBMS의 창시자인 에드거 커드는 관계형 모델을 고안한 인물이다. 관계형 모델을 채택한 DB를 관계형 DB라 부른다. 관계형 모델에서의 관계형은 수학 집합론의 관계형 이론에서 유래했다.

### UNION으로 합집합 구하기

집합의 연산에는 합집합이라는 것이 있다. 이는 집합을 서로 더한 것을 말한다.

```sql
SELECT * FROM SAMPLE1_A
UNION
SELECT * FROM SAMPLE1_B;
```

UNION으로 두 개의 SELECT 명령을 하나로 연계해 질의 결과를 얻을 수 있다. 즉, UNION을 이용하면 여러 개의 SELECT 명령을 하나로 묶을 수 있다. 이 때 주의점은 각각의 SELECT 명령의 열의 개수와 자료형이 서로 같아야 한다.

UNION을 사용하여 정렬할 때는 주의해야 하는데 UNION으로 SELECT 명령을 연결하는 경우 가장 마지막 SELECT 명령에 대해서만 ORDER BY 구를 지정할 수 있다. ORDER BY 구에 지정하는 열은 별명을 붙여 이름을 일치시킨다.

UNION을 사용하면 합집합으로 서로 더한값을 조회할 수 있는데, 중복값은 존재하지 않는다. 수학에서 합집합은 중복을 제거한다. 만약 중복되는 값까지 모두 조회하려면 `UNION ALL`을 사용하면 된다.

UNION ALL은 두 개의 집합을 단순하게 합치는 것이다. UNION에서는 이미 존재하는 값인지를 검사하는 처리가 필요한 만큼, UNION ALL 쪽이 성능적으로 유리할 경우가 있다. 따라서 중복값이 없는 경우에는 UNION ALL을 사용하는 편이 성능적으로 유리하다.

## 테이블 결합

테이블 결합(JOIN)은 RDBMS에서 굉장히 중요한 개념이다. 테이블 결합은 집합 연산에서 곱집합에 해당한다.

![join-1](/book/sql-first-step/images/join-1.png)

(출처 사진: https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins)

## 관계형 모델

SQL은 관계형 모델에 의해 구축된 DB를 조작하는 체계적인 명령의 집합이다.

### 관계형 모델

관계형 모델(Relational Model)의 기본적인 요소는 릴레이션(Relation)이다. 관계형 모델의 릴레이션은 SQL에서 말하는 테이블에 해당된다.

> 릴레이션은 테이블을 말한다.

관계형 모델의 릴레이션에는 몇 가지 속성이 있다. 이 속성은 속성 이름과 형 이름으로 구성된다. 속성은 SQL에서 말하는 열에 해당한다. SQL에서의 행은 관계형 모델에서 튜플(tuple)이라 불린다.

관계형 모델은 데이터 구조에 관해 정의한다. 릴레이션은 튜플의 집합이며, 릴레이션에 대한 연산이 집합에 대한 연산에 대응된다는 이론을 관계대수라고 한다. 이 같은 관계대수의 기본규칙은 다음과 같다.

- 하나 이상의 관계를 바탕으로 연산한다.
- 연산한 결과, 반환되는 것 또한 관계이다.
- 연산을 중첩 구조로 실행해도 상관없다.

## 데이터베이스 설계

DB를 설계한다는 것은 DB의 스키마 내에 테이블, 인덱스, 뷰 등의 DB 객체를 정의하는 것을 말한다. 스키마 내에 정의한다는 뜻에서 스키마 설계라 불리기도 한다.

DB 설계의 주된 내용은 테이블의 이름이나 열, 자료형을 결정하는 것이다. 이 테이블은 이 열을 이용해 저쪽 테이블과 연결한다와 같이 테이블 간의 관계를 생각하면서 여러 테이블을 정의하고 작성하게 된다.

> 테이블의 물리명은 CREATE TABLE에 지정하는 테이블 이름이나 열 이름이다.  
> 논리명은 설계상의 이름이다.

## 정규화

테이블을 올바른 형태로 변경하고 분할하는 것을 정규화라 한다. 정규화는 DB의 설계 단계에서 행해진다. 경우에 따라서는 기존 시스템을 재검토할 때 정규화하는 경우도 있다.

### 제1정규형

관계형 DB의 테이블에는 하나의 셀에 하나의 값만 저장할 수 있다는 제약이 있다. 즉, 주문상품의 경우 적어도 상품코드와 상품명, 개수 데이터를 담은 세 개의 열로 나누어야 한다. 이렇게 하나의 셀에 하나의 값만 저장할 수 있도록 하고, 반복되는 부분을 세로(행) 방향으로 늘려나가는 것이 제1정규화의 제1단계이다.

제1정규화에서는 중복을 제거하는 테이블의 분할도 이루어진다. 반복되는 부분을 테이블 분할함으로서 주문 데이터가 변경되더라도 한 군데만 수정하면 된다. 주문 테이블에서는 중복된 데이터가 없으므로 주문번호를 기본키로 지정할 수 있다. 이처럼 제1정규화에서는 테이블 분할과 기본키 지정이 이루어진다.

### 제2정규형

제2정규화에서는 데이터가 중복되는 부분을 찾아내어 테이블로 분할해나간다. 이때 기본키에 의해 특정되는 열과 그렇지 않은 열로 나누는 것으로 정규화가 이루어진다. 다른 말로 부분 함수종속성을 찾아내서 테이블을 분할하는 것이 제2정규화이다. 함수종속성이란 키 값을 이용해 데이터를 특정지을 수 있는 것을 가리킨다.

### 제3정규형

이 또한 중복하는 부분을 찾아내어 테이블을 분할하는 수법이다. 제2정규화의 경우 기본키에 중복이 없는지 조사했다면 제3정규화에서는 기본키 이외의 부분에서 중복이 없는지를 조사한다.

### 정규화의 목적

정규화에서는 중복하거나 반복되는 부분을 찾아내서 테이블을 분할하고 기본키를 작성해 사용하는 것을 기본 개념으로 삼는다. 이는 하나의 데이터는 한 곳에 있어야 한다는 규칙에 근거한다. 결국 정규화로 데이터 구조를 개선하는 것은 하나의 데이터가 한 곳에 저장되도록 하기 위함이다.

하나의 데이터가 반드시 한 곳에만 저장되어 있다면 데이터를 변경하더라도 한곳만 변경하는 것으로 끝낼 수 있다. 반면 정규화되지 않은 경우에는 여기저기 중복해서 저장된 데이터를 검색하고 일일이 변경해야 한다.

## 트랜잭션

```sql
트랜잭션 제어
START TRANSACTION
COMMIT
ROLLBACK
```

DB는 트랜잭션이라는 기능을 제공한다. 예를 들어, 계좌이체이를 생각해보자.

- A 사용자는 B 사용자에게 5000원을 이체한다.
- B 사용자는 A 사용자로부터 5000원 받는다.

위 2개의 행위는 한 번의 트랜잭션으로 이루어져야 한다. 만약 둘 중 하나라도 제대로 수행하지 않으면 큰 장애가 발생하게 된다. 이처럼 몇 단계로 처리를 나누어 SQL 명령을 실행하는 경우에 트랜잭션을 자주 사용한다. 만약 중간에 에러가 발생하면 트랜잭션 롤백해서 모두 원복시킬 수 있다. 그리고 모두 정상적으로 수행되면 트랜잭션 커밋을 수행하여 DB에 완전히 반영하게 된다.

지금까지 INSERT, UPDATE, DELETE 등 대부분 자동커밋을 사용한다. 트랜잭션을 사용하기 위해서는 이 자동커밋을 꺼야한다.
