# [Book] 모두의 깃 & 깃허브

지금부터 정리할 내용은 책 [모두의 깃 & 깃허브](https://www.yes24.com/Product/Goods/110795446)와 인프런 강의인 [모두의 깃 & 깃허브](https://www.inflearn.com/course/%EB%AA%A8%EB%91%90%EC%9D%98-%EA%B9%83-%EA%B9%83%ED%97%88%EB%B8%8C)를 참고하였습니다. 제대로 공부하시려면 위 2가지를 모두 직접 학습하시는 것을 추천드립니다.

## 목차

- [깃이 없는 세상](#깃이-없는-세상)
- [버전](#버전)
- [깃이란](#깃이란)
- [버전 관리의 큰 그림](#버전-관리의-큰-그림)
- [.gitignore](#gitignore)
- [깃 명렁어를 알아야 하는 이유](#깃-명렁어를-알아야-하는-이유)
- [태그와 릴리스](#태그와-릴리스)
- [버전 비교하기]()
- [작업 되돌리기](#작업-되돌리기)
- [스태시로 작업 임시 저장하기](#스태시로-작업-임시-저장하기)
- [브랜치](#브랜치)
- [충돌](#충돌)
- [브랜치 재배치하기](#브랜치-재배치하기)
- [깃허브](#깃허브)
- [SSH](#ssh-secure-shell)
- [원격 저장소와의 네 가지 상호 작용](#원격-저장소와의-네-가지-상호-작용)
- [풀 리퀘스트: 깃허브로 협업하기](#풀-리퀘스트-깃허브로-협업하기)

## 깃이 없는 세상

- 변경 내역을 확인하기 어렵다.
  - 하나의 파일로 협업한다면 수정하게 되면 어떤 내용이 수정되었는지 확인하기 어렵다.
  - 버전 파일을 매번 계속 만든다면 파일을 관리하기 힘들어진다.
- 버전을 되돌리기 어렵다.
- 협력하기 어렵다.
  - 수정한 파일을 매번 협업자에게 전달해야 하고, 그 전달한 파일이 잘못 전달하는 실수가 발생한다.

## 버전

새로운 버전은 주로 기능이 새로 추가되거나 크고 작은 버그가 수정되는 등 기존과는 다른 유의미한 변화가 생겼을 때 만들어진다. 즉, 버전이란 **유의미한 변화가 결과물론 나온 것, 유의미한 변화가 결과물로 저장된 것**을 의미한다.

버전 관리란, 이러한 유의미한 변화를 쌓아 올리면서 소프트웨어를 만들어가는 과정이다.

- 변경 내역들을 기억한다.
- 필요하다면 작업을 되돌린다.
- 여러 명의 코드를 쉽게 나누고 합치며 개발한다.

> **버전 vs 패치 vs 업데이트**  
> 패치는 시급한 오류 해결을 동반하거나 비교적 규모가 작은 버전이라는 의미가 강하다.  
> 업데이트는 패치의 의미와 더불어 Windows 업데이트처럼 주기적으로 추가되는 버전, 새롭게 추가되는 기능을 담은 버전이라는 의미도 포함한다.

## 깃이란

깃은 버전 관리를 도와주는 소프트웨어로, 버전 관리 시스템(Version Control System, VCS)이다. 이러한 깃을 이용해서 버전을 만들고 되돌리며, 다른 개발자들과 협업할 수 있다.

### 소스트리

깃을 좀 더 편리하게 사용할 수 있게 도와주는 도구이다. 깃 GUI(Graphic User Interface) 중 대표적인 툴이라 할 수 있다.

> 소스트리 안켜짐  
> 소스트리가 안켜질 때 https://jerryjerryjerry.tistory.com/179 를 참고하자.

## 버전 관리의 큰 그림

버전이 만들어지는 과정을 이해하려면 깃이 관리하는 세 개의 공간, 작업 디렉터리(working directory), 스페이지(stage), 저장소(repository)를 먼저 이해해야 한다.

여기서 스테이지와 저장소는 깃이 관리하는 가상의 공간이다.

깃이 관리하는 세 개의 공간

- 작업 디렉터리: 버전 관리의 대상이 위치하는 공간
- 스테이지: 다음 버전이 될 후보가 올라가는 공간
- 저장소: 버전이 만들어지고 관리되는 공간

### 작업 디렉터리

![working-directory-1](/book/git-for-everyone/images/working-directory-1.png)

깃을 이용해 작업 디렉터리 내에 위치한 파일 및 폴더의 현재 상태를 버전으로 만들고, 만들어진 버전을 관리할 수 있다. 즉, 작업 디렉터리는 버전 관리의 대상이 위치하는 공간을 말한다. (.git이 만들어진 공간)

여기서 버전을 만든다는 의미는 특정 순간의 변경 사항을 기억한다와 같다. 따라서 작업 디렉터리에 있는 프로젝트에 변경 사항이 생기는 순간 새로운 버전을 만들 수 있게 된다.

이 때 모든 변경 사항을 새로운 버전으로 만들 필요가 없는데, 모든 변경 사항 중에서도 새로운 버전으로 만들 필요가 있는 것과 없는 것을 구분하기 위해 **스테이지**가 있다.

### 스테이지

![stage-1](/book/git-for-everyone/images/stage-1.png)

깃으로 버전을 만들 때는 작업 디렉터리 내에서 변경된 파일들 중에서 새로운 버전이 될 파일만 특별한 공간으로 옮기는 작업을 거치게 된다. 이 특별한 공간이 바로 **스테이지**이다. 즉, 스테이지는 변경 사항이 있는 파일 중 다음 버전이 될 후보가 올라가는 공간인 셈이다.

다시 말해, 버전을 만들기 위해 작업 디렉터리에 있는 파일에 변경 사항을 만들고, 이 변경 사항들 중 새로운 버전으로 만들려는 파일을 선별해 스테이지로 옮긴다.

작업 디렉터리에서 버전이 될 후보 파일을 스테이지로 옮기는 것을 스테이지에 추가한다(add) 또는 해당 파일을 스테이지시킨다(staged) 라고 표현한다.

> 스테이지는 스테이징 영역(staging area) 또는 인덱스(index)라고도 부른다.

### 저장소

![repository-1](/book/git-for-everyone/images/repository-1.png)

스테이지에 있는 파일을 바탕으로 새로운 버전을 만들면 새 버전이 저장소에 추가된다. 즉, 저장소는 버전이 만들어지고 관리되는 공간이다.

![commit-1](/book/git-for-everyone/images/commit-1.png)

저장소에 새로운 버전을 만드는 것을 커밋한다(commit) 라고 표현한다. 각 커밋에는 고유한 커밋 해시가 있다. 커밋 해시란 마치 학번, 사번과 같이 각 커밋이 가진 고유한 ID이다.

하나의 버전은 다음과 같은 과정을 통해 만들어진다.

1. 작업 디렉터리에서 변경 사항 생성하기
2. 스테이지로 올리기 (add)
3. 커밋하기 (commit)

#### 커밋 메시지

커밋 메시지란, 버전을 설명하는 메시지다. 내가 지금 어떤 파일을 어떻게 변경했는지, 왜 이렇게 변경했는지 등의 내용을 담은 일종의 쪽지라고 볼 수 있다. 커밋 메시지는 자칫 별것 아닌 것처럼 보일지라도 여러명의 개발자들끼리 협업하기 위해서는 매우 중요한 의사소통 수단이 된다.

> 커밋 메시지를 작성하는 방법이 따로 있다.  
> 구글에 커밋 메시지 컨벤션 이라고 검색하면 많은 정보를 확인할 수 있다.

## .gitignore

종종 버전 관리 대상에서 제외하고 싶은 파일이나 폴더, 즉 변경 사항이 생기더라도 앞으로도 쭉 버전에 포함하고 싶지 않은 파일이나 폴더 있을 수 있다. **.gitignore** 파일은 쉽게 말해 무시할 파일/폴더 목록을 적은 파일을 말한다.

## 깃 명렁어를 알아야 하는 이유

이유는 간단하다. 소스트리를 사용할 수도 있지만 소스트리와 깃 명령어 중 둘다 익숙하다면 깃 명령어를 사용하는 것이 훨씬 더 빠르고 편리하기 때문이다. 깃 명령어를 한번 손에 익혀두면 명령어 한두 줄로 간단하게 버전을 다룰 수 있다. 이는 버전을 관리할 때마다 일일이 소스트리를 열고 마우스로 버튼을 클릭하는 것보다 훨씬 빠르고 간편한 방식이다.

### 1. git init: 로컬 저장소 만들기

```bash
git init
```

### 2. git status: 작업 디렉터리 상태 확인하기

```bash
git status
```

현재 작업 디렉터리의 상태를 알려주는 명령어이다.

### 3. git add: 스테이지에 올리기

```bash
git add a.txt //파일 하나만 올리기
git add . //모든 파일 올리기
```

### 4. git commit: 커밋하기

```bash
git commit //커밋 메시지를 작성하기 위한 vi 편집기로 진입한다.
git commit -m "first commit"
git commit -am "second commit" //add와 commit을 동시에 수행한다.
```

참고로 `git commit -am "커밋 메시지"` : 이 명령은 깃이 변경 사항을 추적하는(tracked) 파일에만 사용 가능합니다. 즉, 스테이지에 이미 올라와 있거나 한 번이라도 커밋한 적이 있는 파일에만 사용할 수 있다.

### 5. git log

```bash
git log
git log --oneline
git log --patch or git log -p
git log --graph
git log --branches
```

커밋한 내역을 확인하기 위한 명령어이다.

- `git log`: 기본적으로 현재 브랜치를 기준으로 커밋 목록을 조회한다.
- `git log --oneline` : 커밋 목록을 단순한 형태로 보고 싶은 경우 사용한다. 이 명령은 짧은 커밋 해시와 커밋 메시지 제목만을 출력한다.
- `git log --patch or git log -p` : 해당 커밋으로 어떤 파일이 어떻게 수정됐는지 상세하게 출력한다.
- `git log --graph` : 각 커밋을 그래프의 형태로 출력하는 방법이다.
- `git log --branches` : 이 명령은 모든 브랜치의 커밋 목록을 조회할 수 있는 옵션이다.

## 태그와 릴리스

모든 의미 있는 소프트웨어는 사용자가 있다. 웹서비스든 앱이든 깃처럼 개발을 돕기 위한 도구든, 모든 소프트웨어는 사용하기 위해 만들어진 존재이다.

로그인 기능, 글쓰기 기능, 버그 수정 등 커밋이 쌓이며 웹 서비스 또는 앱이 점차 완성되어 간다. 그러다 이제 충분히 개발됐다고 판단하면 사용자에게 결과물을 선보일 것이다.

개발한 소프트웨어를 사용자에게 선보이는 것을 **릴리스(release)** 라고 한다. 즉, 커밋이 쌓이면 언젠간 사용자에게 릴리스하게 된다.

이 때 사용자에게 선보이는 버전은 어떻게 표기하는 것이 좋을까? 커밋에 고유한 해시 값이 있으나 이는 가독성이 좋지 않다.

이럴 때 사용하는 것이 바로 태그(tag)다.

각 커밋에는 커밋 해시라는 고유한 문자열이 있고, 이렇게 쌓이고 쌓인 커밋에 태그라는 꼬리표를 붙일 수 있다. 그리고 이 꼬리표 안에는 보통 버전을 작성하는 규칙에 따라 작성된 버전을 명시하고, 사용자에게 내놓을 준비가 끝나면 이를 릴리스하게 된다.

> 태그 버전 명시  
> 태그에 버전을 작성한다고 했는데 이 때 버전을 작성하는 규칙이 있다. 이 규칙은 구글에 역시 검색해보자.

### 태그 추가 명령어

```bash
git tag v1.0.0
git tag v1.0.0 376a124
```

`git tag v1.0.0` : 최신 커밋에 태그가 붙는다.
`git tag v1.0.0 376a124` : 특정 커밋에 태그가 붙는다.

### 태그 삭제 명령어

```bash
git tag --delete v1.0.0
git tag -d v1.0.0
```

### 태그 목록 조회 명령어

```bash
git tag --list
git tag -l
git tag
```

위 3개의 명령어 모두 태그 목록을 조회하는 명령어이다.

## 버전 비교하기

소스트리에서는 버전을 비교할 때 눈으로 바로 확인할 수 있었다. 명령어로는 `git diff`를 사용한다.

```bash
git diff
git diff --staged
git diff <커밋1> <커밋2>
git diff <기준이 되는 브랜치> <기준과 비교할 브랜치>
```

- `git diff` : 최근 커밋과 현재 작업 디렉터리의 차이를 추력한다. 이 명령은 보통 커밋한 이후로 작업 디렉터리에서 무엇을 수정했는지 확인하기 위해 사용한다.
- `git diff --staged` : 스테이지에 추가된 항목과 최근 커밋의 차이를 보여주는 명령이다.
- `git diff <커밋> <커밋>` : 커밋끼리 비교할 때 쓰는 명령어인데 주의할 점이 있다. 바로 두 커밋의 순서가 바뀌면 전혀 다른 결과가 나온다.
  - 커밋2는 커밋1에 비해서 뭐가 다른지 비교한다.
- `git diff <기준이 되는 브랜치> <기준과 비교할 브랜치>` : 브랜치끼리 버전을 비교할 수 있다.

## 작업 되돌리기

- 아직 스테이지로 올리지 않은 변경된 파일을 취소하려면 어떻게 해야할까?
- 스테이지에 올라간 파일은 어떻게 취소할까?
- 이미 커밋한 파일은 어떻게 취소할 수 있을까?

### 커밋 되돌리기

이미 커밋한 내용을 되돌리는 방법은 크게 두 가지가 있다.

- revert
- reset

### revert

![revert-1](/book/git-for-everyone/images/revert-1.png)

revert는 버전을 되돌리되, 되돌아간 상태에 대한 새로운 버전(커밋)을 만드는 방식이다. 중요한 점은 **기존의 버전은 삭제되지 않는다**는 점이다.

revert를 하는 가장 큰 이유는 기존에 만들어두었던 파일들은 유지하며, 버전을 되돌린 새로운 버전을 만드는 것에 의미가 있다.

### 명령어

```bash
git revert 095e3ba
```

reset이 특정 커밋으로 되돌아가는 방식이라면, revert는 해당 커밋을 취소한 새로운 커밋을 추가하는 방식이다. 참고로 주의할 점이 있는데, git reset은 뒤에 되돌아갈 커밋을 명시하고 git revert는 뒤에 취소할 커밋을 명시한다.

### reset

reset은 되돌아갈 버전의 시점으로 완전하게 되돌아가는 방식이다. 즉, **되돌아갈 버전 이후의 버전은 삭제되는 방식**이다.

reset에는 크게 세 종류 **soft, mixed, hard** 가 있다.

- soft: 작업 디렉터리 내 변경 사항과 스테이지에 추가된 변경 사항은 유지하되, 커밋했다는 사실만 되돌리는 reset을 soft reset 이라고 한다.
- mixed: 작업 디렉터리 내 변경 사항은 유지하되, 스테이와 커밋을 되돌리는 reset을 mixed reset 이라고 한다.
- hard: 작업 디렉터리 내 변경 사항까지 통째로 되돌리는 reset을 hard reset 이라고 한다.

**soft reset**

작업 디렉터리 내 변경 사항과 스테이지에 추가된 변경 사항은 유지

![soft-reset-1](/book/git-for-everyone/images/soft-reset-1.png)

**mixed reset**

작업 디렉터리 내 변경 사항은 유지

![mixed-reset-1](/book/git-for-everyone/images/mixed-reset-1.png)

**hard reset**

유지 X

![hard-reset-1](/book/git-for-everyone/images/hard-reset-1.png)

### 명령어

```bash
git reset --soft 095e3ba
git reset --mixed 095e3ba
git reset --hard 095e3ba
```

- git reset --soft HEAD^ 또는 git reset --soft HEAD~1과 동일하다.

## 스태시로 작업 임시 저장하기

![stash-1](/book/git-for-everyone/images/stash-1.png)

깃은 스태시(stash)라는 임시 저장 기능을 지원한다.  
파일 수정하면서 아래와 같은 상황이 발생할 수 있다.

1. 작업 내역이 썩 마음에 들지 않지만 버리기는 아까울 때
2. 갑자기 다른 더 중요한 일을 처리해야 할 때

위와 같이 지금까지의 변경 내역을 전부 지워버리는 것보다 어딘가에 임시 저장해두면 좋다.

스태시를 사용하게 되면 작업 디렉터리에서 생성한 모든 변경 사항이 임시 저장되고, 작업 디렉터리는 변경 사항이 생기기 전의 깨끗한 상태로 돌아간다.

또한 스태시로 임시 저장된 변경 사항들은 언제든 다시 꺼내어 작업 디렉터리에 다시 적용할 수 있다.

> 참고  
> 스태시는 깃이 변경 사항을 추적하는(tracked) 파일에만 사용할 수 있다. 즉, 스테이지에 이미 올라와 있거나 한번이라도 커밋한 적이 있는 파일에만 사용이 가능하다.  
> 방금 막 생성한 파일처럼 깃이 기존에 변경 사항을 추적하지 않은(untracked) 파일에는 스태시를 사용할 수 없다.

### 명렁어

```bash
git stash -m "메시지 내용"
git stash list
git stash apply <스태시>
git stash drop <스태시>
```

- `git stash -m "메시지 내용"` : 어떤 내용으로 임시 저장했는지 스태시 명령어
- `git stash list` : 임시 저장된 작업 내역을 조회한다.
- `git stash apply <스태시>` : 임시 저장된 작업을 적용한다.
- `git stash drop <스태시>` : 임시 저장된 작업을 삭제한다.

## 브랜치

### 브랜치가 필요한 이유

#### 브랜치가 없는 경우

![branch-1](/book/git-for-everyone/images/branch-1.png)

A 작업자는 장바구니 기능을, B 작업자는 주문 목록 기능을 각자 개발해서 코드를 합치려고 하면 서로 추가 및 수정한 코드를 비교해 가면서 합칠 코드를 판단해간다.

이러면 실수할 확률이 높아져서 굉장히 번거롭다.

- 서로 어느 부분을 수정했는지 매번 체크해야 한다.
- 같은 부분을 서로 다르게 수정하는 혼재가 생긴다.
- 일일이 수작업으로 합쳐야 한다.
- 때로는 서로의 코드를 합치다 실수가 생길 수 있다.
- 버전을 만들고 릴리스하고 나서 요구사항이 계속 들어온다면 이를 또 관리하려면 쉽지 않다.

이러한 이유로 브랜치를 사용하면 위의 번거로운 점들을 모두 해결해주고, 각자의 브랜치에서 작업하고 손쉽게 합칠 수 있게 된다.

### 브랜치란

![branch-2](/book/git-for-everyone/images/branch-2.png)

브랜치는 마치 줄기에서 뻗어나오는 나뭇가지와 같이 버전을 여러 흐름으로 나누어 관리하는 방법이다. 브랜치는 **버전의 분기** 를 말한다.

![branch-4](/book/git-for-everyone/images/branch-4.png)

여러 흐름으로 버전을 나누어 관리한다는 말은 다음 3단계로 버전을 관리하는 것을 말한다.

1. 브랜치를 나눈다.
2. 각자의 브랜치에서 작업한다.
3. (필요한 경우) 나눈 브랜치를 합친다.

### 명령어

```bash
git branch
```

현재 브랜치의 목록과 함께 현재 작업중인 브랜치가 \*로 표시된다.

### 브랜치 나누기

깃이 제공하는 가장 기본적인, 최초의 브랜치를 master 브랜치라고 한다.  
여기서 알아야 할 개념이 있는데 바로 HEAD와 체크아웃이다.

- HEAD: 기본적으로 현재 작업중인 브랜치의 최신 커밋을 가리키는 일종의 표시이다.
- 체크아웃: 특정 브랜치에서 작업할 수 있도록 작업 환경을 바꾸는 것을 말한다.
  - HEAD의 위치를 특정 브랜치의 최신 커밋으로 옮긴다.

특정 브랜치로 체크아웃하게 되면 HEAD의 위치가 해당 브랜치의 최신 커밋을 가리키게 되고, 작업 디렉터리는 체크아웃한 브랜치의 모습으로 바뀌게 된다.

> 참고  
> 실무에서 브랜치 이름은 마음대로 지으면 이 브랜치가 무엇을 위해 만들어졌는지 알 수가 없다. 따라서 새로운 기능을 개발하기 위한 브랜치 이름은 `feature/<새 기능>` 처럼 암묵적으로 정해두는 편이다.  
> 자세한 내용은 브랜치 이름 짓기 같은 키워드로 구글에 검색하면 나온다.

### 명령어

```bash
git branch foo
git checkout <브랜치>
git checkout -b <브랜치>
git branch -M <브랜치>
```

- `git branch foo` : 브랜치를 생성한다.
- `git checkout <브랜치>` : 특정 브랜치로 체크아웃, 특정 작업 환경으로 바꾼아.
- `git checkout -b <브랜치>` : 브랜치를 생성과 동시에 생성된 브랜치로 체크아웃한다.
- `git branch -M <브랜치>` : 현재 브랜치의 이름을 <브랜치>로 바꾸는 명령이다. 참고로 브랜치 이름을 바꾸는 경우는 비교적 드물다.

### 브랜치 병합하기

브랜치 나누었다면 이제 나눈 브랜치를 하나로 통합하는 것을 병합 영어로는 merge 라고 한다.

### 빨리 감기 병합

![merge-1](/book/git-for-everyone/images/merge-1.png)

다른 브랜치를 master 브랜치에 병합하는 과정을 보자.

master 브랜치 입장에서는 자신의 브랜치가 마치 빨리 감기 하듯이 다른 브랜치와 동일하게 업데이트가 되는데 이렇게 될 수 있는 이유는 master 브랜치에서부터 뻗어나온 뻗어나온 시점부터 병합되는 순간까지 master 브랜치에 어떤 변환도 없었기 때문이다. 즉, 다른 브랜치는 master 브랜치에서 뻗어나온 이후로 여러 커밋이 쌓였지만, 그동안 master 브랜치는 어떠한 새로운 커밋도 없이 그저 가만히 있었다.

그렇기 때문에 다른 브랜치를 master 브랜치로 병합할 적에 master 브랜치는 그저 다른 브랜치에 새롭게 쌓인 커밋을 반영만 하면 된다.

이처럼 변화가 없었던 브랜치가 마치 빨리 감기 하듯 업데이트되는 병합 기법을 빨리 감기 병합(fast-forward merge)라고 한다.

그렇다면 빨리감기 병합이 아닌 병합은 어떤걸까?

![merge-2](/book/git-for-everyone/images/merge-2.png)

bar 브랜치에는 없는 커밋이 master 브랜치에 있고, master 브랜치에 없는 커밋이 bar 브랜치에 있는 상황에서 bar 브랜치를 master 브랜치에 병합하는 것이다.

위 상황에서는 master 브랜치는 가만히 있지 않았다. (4번 커밋, 5번 커밋 진행)

![merge-3](/book/git-for-everyone/images/merge-3.png)

따라서 merge 할 경우에는 **새로운 커밋이 생성**된다.

### 명령어

```bash
git merge foo
```

- `git merge foo` : foo 브랜치가 master 브랜치로 병합된다.

병합한 뒤에 foo 브랜치는 삭제하는 것이 좋다.

```bash
git branch -d <브랜치>
```

## 충돌

![collision-1](/book/git-for-everyone/images/collision-1.png)

앞에서 브랜치 병합하는 과정에서 충돌이 발생할 수 있다.  
충돌이란 병합하려는 두 브랜치가 서로 같은 내용을 다르게 수정한 상황을 의미한다.

충돌이 발생하게 되면 브랜치가 한 번에 병합되지 못한다. 충돌은 여럿이 협업하여 개발할 때 빈번히 발생하므로 언제 발생하고, 어떻게 해결할 수 있는지 꼭 알아야 한다.

즉, 충돌이 발생했다는 것은 깃도 해결할 수 없다는 의미이고, 깃이 어떤 브랜치의 내용을 반영해야 할지 판단할 수 없다. 이처럼 같은 내용을 다르게 수정한 두 브랜치를 병합하는 상황을 충돌이 발생했다고 한다.

충돌이 발생하면 최종적으로 어떤 브랜치의 내용을 반영할지는 개발자 협업분들이 모여서 직접 상의하고 선택해야 한다.

### 충돌 해결하기

브랜치를 병합하는 과정에서 충돌이 발생했을 경우, 충돌이 발생한 파일들의 충돌을 해결한 뒤 다시 커밋해야만 브랜치가 올바르게 병합된다.

같은 내용을 다르게 수정한 브랜치 중 어떤 브랜치 내용을 최종적으로 반영할지를 직접 선택하는 것을 충돌을 해결한다 라고 한다.

### 충돌시 기호 표기

```text/plain
<<<<<<< HEAD
master <----- master 브랜치 내용
=======
foo <----- foo 브랜치 내용
>>>>>>> foo
```

- HEAD가 가리키는 브랜치, 즉 현재 체크아웃한 브랜치의 내용이 적혀있다.
- 아랫 부분은 병합하려는 브랜치, 즉 foo 브랜치의 내용이 적혀있다.
- 이는 <<<<<<< 기호와 ======= 기호 사이의 내용을 선택할지, ======= 기호와 >>>>>>> 기호 사이의 내용을 선택할지 고르라는 표기이다.

## 브랜치 재배치하기

브랜치의 재배치는 rebase 라고 한다.

![rebase-1](/book/git-for-everyone/images/rebase-1.png)

먼저 위와 같은 상황이 있다고 가정하자.  
이 상황에서 foo 브랜치를 네 번째 커밋에서 뻗어나오도록 변경한다. 이처럼 **브랜치가 뻗어나온 기준점을 변경하는 것**을 브랜치의 재배치, rebase 라고 한다.

### merge와 rebase

![rebase-4](/book/git-for-everyone/images/rebase-4.png)

앞선 빨리감기 병합이 아닌 병합에 대해 알아보았다. 일반적인 merge는 브랜치가 남아있고 **새로운 커밋이 생성**된다.

![rebase-3](/book/git-for-everyone/images/rebase-3.png)

반면에 rebase는 브랜치가 남아있지 않고 master 브랜치에 이어져있는 것을 볼 수 있다. 즉, **새로운 커밋이 생성되지 않고** master 브랜치의 HEAD에 재배치된 것을 확인할 수 있다.

또한 rebase 역시 병합하는 과정이기 때문에 충돌이 발생할 수 있다.

### 명령어

```bash
git rebase master
```

bar 브랜치를 master 브랜치로 재배치하려면 bar 브랜치로 체크아웃 한 뒤 `git rebase master` 명령을 입력하면 된다.

## 깃허브

깃허브는 개발자의 SNS이다. 그리고 백업을 할 수 있고 개발자 간에 협업을 가능케하는 **원격 저장소 호스팅 서비스**이기도 한다.

### 원격 저장소 호스팅 서비스, 깃허브

원격 저장소란, 이름 그대로 원격(remote)에 있는 저장소이다. 앞선 실습으로 개인 로컬에 저장소를 만들어서 실습 연습을 할 수 있었는데 이 저장소는 우리들의 개인 컴퓨터 속에만 존재하는 저장소이다. 이를 로컬(local)에 있는 저장소, 로컬 저장소라 한다.

### 원격 저장소는 왜 있는걸까?

원격 저장소는 우리들의 컴퓨터 속에만 있는 저장소가 아닌, 인터넷 세상 어딘가에 있는 다른 컴퓨터 속의 저장소를 의미한다.

이러한 원격 저장소가 있으면 2가지 장점이 있는데 바로 백업과 협업이다.

#### 백업

만약 열심히 개발한 프로젝트가 로컬 저장소에만 있다면 우리들의 컴퓨터가 고장나거나 실수로 로컬 저장소를 삭제할 경우 큰일이 날 것이다. 하지만 로컬 저장소의 프로젝트를 원격 저장소에 백업해주고, 언제든 원격 저장소에서 프로젝트를 내려받아 사용할 수 있다면 우리들의 컴퓨터가 망가지거나 로컬 저장소가 삭제되어도 전혀 우리가 되지 않는다.

#### 협업

![remote-1](/book/git-for-everyone/images/remote-1.png)

원격 저장소를 이용하면 다른 개발자들과 협업도 수월하게 할 수 있다.  
모든 개발자가 이해하는 공통 코드를 원격 저장소에 업로드하고, 이를 내려받아 새로운 커밋들을 추가한 뒤 이를 다시 원격 저장소에 추가하는 방식으로 작업한다면 로컬 저장소에서만 작업하는 것보다 훨씬 효율적으로 협업할 수 있게되기 때문이다.

## SSH (Secure Shell)

![](/book/git-for-everyone/images/ssh-1.png)

SSH는 깃허브와 개인 컴퓨터가 안전하게 통신을 주고받을 수 있는 방법을 말한다. (사실 더 많은 내용이 있지만 여기서는 이정도만 알아두자.)

먼저 SSH 통신을하려면 개인 컴퓨터에서 키(key) 두개를 생성해야 한다. 하나는 공개키(public key), 또 다른 하나는 개인 키(private key)이다. 공개키는 모두에게 공개된 키이고, 개인키는 본인만 알고 있어야 하는 키다. 여기서 키는 열쇠라는 뜻도 있지만 암호, 또는 암호화된 문자열이라고 생각해도 좋다.

공개키와 개인키를 생성하여 통신하려는 대상에게 공개키를 건네주면 된다. SSH 통신은 암호화된 통신 방법이므로 개인 컴퓨터와 공개키를 전달받은 깃허브 사이에 주고받는 대화는 암호화되어 전송된다. 또한 개인키가 있어야지만 깃허브에 본인을 증명하고, 깃허브와 주고받는 내용을 이해할 수 있다.

```terminal
ssh-keygen
```

위 간단한 명령어로 SSH 키를 생성할 수 있다.

- 공개키: id_rsa.pub
- 개인키: id_rsa

### 깃허브의 SSH 설정

1. profile > Settings > SSH and GPG keys > New SSH key 버튼 클릭
2. Key의 내용에는 공개키인 id_rsa.pub 파일의 내용을 그대로 복사해서 붙여넣는다. 끝.

## 원격 저장소와의 네 가지 상호 작용

1. 클론(clone): 원격 저장소를 복제하기
2. 푸시(push): 원격 저장소에 밀어넣기
3. 패치(fetch): 원격 저장소를 일단 가져만 오기
4. 풀(pull): 원격 저장소를 가져와서 합치기

### 원격 저장소 브랜치 이름

- main 브랜치: master 브랜치와 같다.
- origin: 원격 저장소 경로에 붙은 일종의 별명이다.
  - DNS를 생각하면 이해할 수 있다.
- origin/main: 원격 저장소 origin의 main
- origin/HEAD: 원격 저장소 origin의 HEAD

### 클론 (clone)

![clone-1](/book/git-for-everyone/images/clone-1.png)

말 그대로 깃허브상에 존재하는 모든 원격 저장소를 우리들의 컴퓨터, 즉 로컬로 복사하여 가져오는 방법이다.

```bash
git clone <원격 저장소>
```

### 푸시 (push)

![push-1](/book/git-for-everyone/images/push-1.png)

푸시는 영어로 밀다 라는 뜻이다. 깃에서 사용하는 push는 원격 저장소에 로컬 저장소의 변경 사항을 밀어넣는 것을 의미한다.

```bash
git push -u origin <브랜치>
```

`git push -u origin <브랜치>` : origin으로 <브랜치>를 푸시하는 명령이다. `-u` 옵션은 처음 푸시할 때 한 번만 사용하면 되는데, 이 욥션과 함께 푸시하면 추후 간단히 git push(또는 git pull) 명령만으로 origin의 main 브랜치로 푸시할 수 있다.

### 패치 (fetch)

![fetch-1](/book/git-for-everyone/images/fetch-1.png)

fetch는 가져오다를 의미한다. 패치는 원격 저장소의 변경 사항들을 가져오는 방법, 더 정확하게는 일단 가져만 오는 방법이다.

다른 개발자가 푸시한 내용을 개인 로컬로 가져오고 싶을 때 패치를 사용할 수 있다. 다시 말해, 원격 저장소의 변경 사항을 로컬로 가져오고 싶을 때 패치를 사용한다.

여기서 일단 가져만 오는 방법이란건, **패치를 해도 원격 저장소의 내용이 로컬 저장소에 병합(merge)되지 않는다**는 것을 의미한다. 즉, 패치를 하게 되면 내 로컬 저장소에는 어떠한 영향을 끼치지 않는다.

```bash
git fetch <원격 저장소 이름>
git fetch
```

- `git fetch <원격 저장소 이름>` 또는 `git fetch` 명령어를 사용하면 원격 저장소의 변경 사항을 일단 가져만 온다.

### 풀 (pull)

![pull-1](/book/git-for-everyone/images/pull-1.png)

패치가 원격 저장소를 일단 가져오는 방법이라면 풀(pull)은 원격 저장소를 가져와서 병합(merge)하는 방법이다. 즉, 풀은 **패치와 병합을 동시에 하는 방법**이다.

```bash
git pull <원격 저장소 이름>
git pull
```

- `git pull <원격 저장소 이름>` 또는 `git pull`은 동일하게 원격 저장소의 변경 사항을 가져와서 병합한다.

### git remote: 원격 저장소를 추가, 조회, 삭제하기

`git remote`는 원격 저장소를 추가, 조회, 삭제할 수 있는 명령어이다.

```bash
git remote add origin <원격 저장소>
git remote
git remote -v
git remote rename origin <변경할 원격저장소 이름>
git remote remove changed
```

- `git remote add origin <원격 저장소>` : 원격 저장소 추가
- `git remote` : 원격 저장소의 이름 조회
- `git remote -v` : 원격 저장소의 이름과 경로 조회
- `git remote rename origin <변경할 원격저장소 이름>` : 원격 저장소의 이름을 origin에서 changed로 변경한다.
- `git remote remove changed` : changed 원격 저장소를 삭제한다.

## 풀 리퀘스트: 깃허브로 협업하기

한 원격 저장소에 여러 개발자가 코드를 기여할 수 있다. 실무에서도 여러 개발자가 한 원격 저장소를 두고 개발하는 것이 일반적이다. 그렇다고 내 원격 저장소가 아닌 소유권이 없는 원격 저장소에는 push 할 수 없다. (당연하다..)

### Collaborator로 추가하여 푸시 권한 주기

원격 저장소 소유자가 Collaborator로 추가한 경우에는 소유하지 않은 계정의 원격 저장소에 푸시할 수 있다. Collaborator는 소유한 원격 저장소의 Settings에서 설정할 수 있다.

하지만 이는 권장하는 방법이 아니며, 대부분은 직접 푸시할 권한이 없는 상태에서 풀 리퀘스트(pull request)로 협업한다.

### 풀 리퀘스트(pull request)

![pull-reuqest-1](/book/git-for-everyone/images/pull-reuqest-1.png)

원격 저장소에 누구나 푸시할 수 있다면 여러 문제가 발생할 수 있다.

이를 해결하기 위해 풀 리퀘스트(pull request)를 사용한다. 풀 리퀘스트는 말 그대로 **원격 저장소가 내 변경 사항을 풀(pull)하도록 요청(request)하는 방법**이다. 즉, "내가 당신의 원격 저장소를 어떻게 변경하고 싶은데, 이 변경을 당신의 저장소로 풀 해주세요!" 하고 부탁하는 방법이라 할 수 있다.

풀 리퀘스트는 다음 단계를 통해 이루어진다.

1. 기여하려는 저장소를 본인 계정으로 포크하기
2. 포크한 저장소를 클론하기
3. 브랜치 생성 후 생성한 브랜치에서 작업하기
4. 작업한 브랜치 푸시하기
5. 풀 origin으로 리퀘스트 작작업하하를 푸시하는 명령이다. `-u` 옵션은 처음 푸시할 때 한 번만 사용하면 되는데, 이 욥션과 함께 푸시하면 추후 간단히 git push(또는 git pull) 명령만으로 origin의 main 브랜치로 푸시할 수 있다.
