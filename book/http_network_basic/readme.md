# [Book] 그림으로 배우는 Http & NetWork Basic

정리할 내용은 [그림으로 배우는 HTTP & Network](https://www.yes24.com/Product/Goods/15894097) 라는 책이다. 오래된 책이여도 근본은 바뀌지 않으니 읽어보면 도움이 분명 된다.

## 목차

- [HTTP](#http)
- [TCP/IP](#tcpip)
- [DNS](#dns)
- [URI와 URL](#uri와-url)
- [클라이언트와 서버 간 통신](#클라이언트와-서버-간-통신)
- [무상태(Stateless)](#무상태stateless)
- [지속 연결](#지속-연결)
- [HTTP 메시지](#http-메시지)
- [상태코드](#상태코드)
- [HTTPS](#https)

## HTTP

웹에서 HTTP는 HyperText Transfer Protocol의 약자로, 클라이언트에서 서버까지 일련의 흐름을 결정하는 프로토콜이다. 프로토콜은 약속이라는 의미로, 웹은 HTTP라는 약속을 사용한 통신으로 이루어져 있다.

### HTTP/0.9

HTTP가 등장한 때는 1990년인데 이 당시 HTTP가 정식 사양서는 아니었다.

### HTTP/1.0

HTTP가 정식 사양으로 공개된 1996년 5월 HTTP/1.0으로 RFC1945가 발행되었다.

### HTTP/1.1

1997년 1월에 공개된 HTTP/1.1 버전이 현재 가장 많이 사용되는 버전이다. (지금도 가장 많이 사용된다.) 당시 사양은 RFC2068이지만 개정판으로 발행된 RFC2616이 최신 버전이다. 그 밖에도 HTTP/2.0, HTTP/3.0도 쓰인다.

## TCP/IP

HTTP를 이해하기 위해서는 TCP/IP 프로토콜에 대해 이해해야 하는데, 인터넷을 포함하여 일반적으로 사용하고 있는 네트워크는 TCP/IP라는 프로토콜에서 움직이고 있다. HTTP는 그 중 하나이다.

컴퓨터와 네트워크 기기가 상호간에 통신하기 위해서는 서로 같은 방법으로 통신하지 않으면 안된다. 따라서 모든 요소에 규칙이 필요한데 이 규칙을 프로토콜이라 한다. 그리고 인터넷과 관련된 프로토콜들을 모은 것을 TCP/IP라고 부른다.

TCP/IP는 애플리케이션 계층, 트랜스포트 계층, 네트워크 계층, 링크 계층 이렇게 4계층으로 나뉘어 있다. 계층화되어 있으면 사양이 변경된 해당 계층만 변경하면 되기 때문에 유연하다. 이를 통해 설계도 편하게 할 수 있다.

### 애플리케이션 계층

애플리케이션 계층은 유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정하고 있다. 예를 들면, FTP와 DNS, HTTP가 이 계층에 해당한다.

### 트랜스포트 계층

트랜스포트 계층은 애플리케이션 계층에 네트워크로 접속되어 있는 2대의 컴퓨터 사이의 데이터 흐름을 제공한다. 트랜스포트 계층에서는 서로 다른 성질을 가진 TCP(Transmission Control Protocol)와 UDP(User Data Protocol) 두 가지 프로토콜이 있다.

### 네트워크 계층

네트워크 계층은 네트워크 상에서 패킷의 이동을 다룬다. 패킷이란 전송하는 데이터의 최소 단위를 말한다.

### 링크 계층 (혹은 데이터 링크 계층, 네트워크 인터페이스 계층)

링크 계층은 네트워크에 접속하는 하드웨어적인 면을 다룬다. 디바이스 드라이버, 네트워크 인터페이스 카드(NIC), 케이블 등

![tcp-ip-1](/book/http_network_basic/images/tcp-ip-1.png)
(출처: https://tychejin.tistory.com/151)

TCP/IP로 통신할 때 계층을 순서대로 거쳐 상대와 통신을 한다.

1. 클라이언트의 애플리케이션 계층(HTTP)에서 어느 웹 페이지를 보고 싶다라는 HTTP 리퀘스트를 날린다.
2. 트랜스포트 계층(TCP)에서는 애플리케이션 계층에서 받은 데이터(HTTP 메시지)를 통신하기 쉽게 조각내어 안내 번호와 포트 번호를 붙여 네트워크 계층에 전달한다.
3. 네트워크 계층(IP)에서는 수신지 MAC 주소를 추가해서 링크 계층에 전달한다. 이로써 네트워크를 통해 송신할 준비가 되었다.

### IP

IP(Internet Protocol)는 네트워크 계층에 해당된다. IP 주소와 혼동할 수 있지만 IP는 프로토콜의 명칭이다.

IP의 역할은 개개의 패킷을 상대방에게 전달하는 것이다.

### TCP

TCP(Transmission Control Protocol)는 트랜스포트 계층에 해당하는데 신뢰성 있는 바이트 스트림 서비스를 제공한다. 바이트 스트림 서비스란 용량이 큰 데이터를 보내기 쉽게 TCP 세그먼트라고 불리는 단위 패킷으로 작게 분해하여 관리하는 것을 말한다. 즉, TCP는 대용량의 데이터를 보내기 쉽게 작게 분해하여 상대에게 보내고, 정확하게 도착했는지 확인하는 역할을 담당한다.

상대에게 확실하게 데이터를 보내기 위해 TCP는 3-way-handshake 이라는 방버을 사용한다. 송신측에서는 최초 SYN 플래그로 상대에게 패킷을 보내고, 수신측에서는 SYN/ACK 플래그로 패킷을 정상 수신한 사실을 전한다. 마지막으로 송신측이 ACK 플래그를 보내 패킷 교환이 완료되었음을 전한다.

## DNS

DNS(Domain Name System)는 HTTP와 같이 응용 계층 시스템에서 도메인 이름과 IP 주소 이름 확인을 제공한다.

## URI와 URL

`https://www.google.co.kr`이 URL이다.

URI는 Uniform Resource Identifiers의 약자로, 스키마를 나타내는 리소스를 식별하기 위한 식별자이다. 스키마는 리소스를 얻기 위한 수단에 이름을 붙이는 방법이다.

`https://www.google.co.kr`에서 `https://`가 스키마다.

## 클라이언트와 서버 간 통신

텍스트와 이미지 등과 같은 리소스를 필요하다고 요구하는 쪽이 클라이언트, 이러한 리소스를 제공하는 쪽이 서버가 된다. HTTP 프로토콜에서는 반드시 한 쪽은 클라이언트 다른 한 쪽은 서버의 역할을 담당한다.

HTTP는 클라이언트가 리퀘스트(요청)하면 서버로부터 리스폰스(응답, 결과)을 받는다. 즉, 반드시 클라이언트로부터 통신이 시작된다.

HTTP는 리소스를 식별하는 URI를 식별하여 어떤 리소스인지 구분할 수 있다.

## 무상태(Stateless)

HTTP는 상태를 계속 유지하지 않는 무상태 프로토콜이다. 즉, 요청 - 응답이 한번 수행되면 그 후로 해당 상태를 유지하지 않는다. 이는 이전에 보냈던 요청이나 되돌려준 응답에 대해서는 전혀 기억하지 않는다. 따라서 새로운 요청이 보내질 때 마다 새로운 응답이 생성된다.

하지만 이렇게 되면 매번 페이지를 요청할 때마다 로그인을 해주어야 하는데 쿠키(Cookie)를 사용하여 문제를 해결할 수 있다.

## 지속 연결

알다시피 HTTP 통신은 TCP/IP 기반으로 하기 때문에 3-way-handshake가 동작한다. 3-way-handshake를 통해서 신뢰성 있는 패킷 교환이 가능했지만 그만큼 시간이 더 걸린다는 단점이 있다. 그래서 `js`, `html`, `css` 등 각각 리소스를 가져올 떄마다 3-way-handshake 통신을 하기 때문에 시간이 배로 걸린다.

지속 연결(Persistent Connections)은 이러한 단점을 보완했다. `js`, `html`, `css` 각각 리소스를 연결하고 종료하는 것이 아니라 한번 연결하고 모든 리소스를 가져와서 그제서야 종료하는 것이다. 이러면 TCP 커넥션의 연결과 종료의 반복되는 오버헤드를 줄여주기 때문에 서버에 대한 부하가 줄어든다. 이는 웹 페이지에 대한 성능을 높여주는 것이다.

## HTTP 메시지

HTTP에서 교환하는 정보를 HTTP 메시지라 불리는데 요청할 때 HTTP 메시지를 요청 메시지, 응답할 때 HTTP 메시지를 응답 메시지라 부른다. HTTP 메시지는 복수 행(개행 문자는 CR+LF)의 데이터로 구성된 텍스트 문자열이다. HTTP 메시지는 크게 구분하면 메시지 헤더와 메시지 바디로 구성되고, 최초에 나타나는 개행 문자로 메시지 헤더와 메시지 바디를 구분한다. 또한 메시지 바디가 항상 존재한다고도 볼 수 없다.

### 요청 메시지

![http-message-1](/book/http_network_basic/images/http-message-1.png)
(출처: https://hahahoho5915.tistory.com/62)

### 응답 메시지

![http-message-2](/book/http_network_basic/images/http-message-2.png)
(출처: https://hahahoho5915.tistory.com/62)

HTTP로 데이터를 전송할 경우 그대로 전송할 수 있지만 전송할 때 인코딩을 수행함으로써 전송 효율을 높일 수 있다. 단, 인코딩 처리로 인하여 CPU 등의 리소스는 더 잡아먹게 된다.

## 상태코드

클라이언트가 서버를 향해 요청 보낼 때 서버에서 그 결과가 어떻게 되었는지 열려주는 것이 상태코드이다.

### 2xx 성공(Success)

2xx 응답은 리퀘스트가 정상으로 처리되었음을 나타낸다

#### 200 OK

클라이언트가 보낸 요청을 서버가 정상 처리함

#### 204 No Content

이 응답은 서버가 요청을 받아서 처리하는데는 성공했지만 응답에 메시지 바디를 포함하지 않았음

### 3xx 리다이렉트(Redirection)

3xx 응답은 요청이 정상적으로 처리를 종료하기 전에 브라우저 측에서 특별한 처리를 수행해야 함을 나타냄

#### 301 Moved Permanently

요청된 리소스에는 새로운 URI가 부여되어 있기 때문에 이후로는 그 리소스를 참조하는 URI를 사용해야 한다는 것을 나타냄. `http://example.com/sample`와 같이 지정했을 때 끝에 슬래시를 붙이는 것을 잊은 경우에 사용

#### 302 Found

요청된 리소스에는 새로운 URI가 할당되어 있기 때문에 그 URI를 참조해 주길 바란다는 의미를 나타냄 301 Moved Permanently와 비슷하지만 302는 영구적인 이동이 아닌 일시적인 것이다.

#### 304 Modified

클라이언트가 조건부 요청을 했을 때 리소스에 대한 액세스는 허락하지만 조건이 충족되지 않음을 표시한다.

### 4xx 클라이언트 에러(Client Error)

4xx 응답은 클라이언트의 원인으로 에러가 발생했음을 나타낸다.

#### 400 Bad Request

요청 구문이 잘못되었음을 나타냄

#### 401 Unauthorized

요청에 HTTP 인증 정보가 필요하다는 것을 나타냄

#### 403 Forbidden

요청된 리소스의 액세스가 거부되었음을 나타냄 (보통 권한 문제)

#### 404 Not Found

요청한 리소스가 서버상에 없는 경우 나타냄

### 5xx 서버 에러(Server Error)

5xx 응답은 서버 원인으로 에러가 발생했음을 나타낸다.

#### 500 Internal Server Error

서버에서 요청을 처리하는 도중에 에러가 발생했음을 나타냄

#### 503 Service Unavailable

일시적으로 서버가 과부하 상태이거나 점검중이기 때문에 현재 요청을 처리할 수 없음을 나타냄

## HTTPS

HTTP가 좋은 것 같지만 보안에 취약하다.

- 평문(암호화 하지 않은) 통신이기 때문에 도청이 가능
- 통신 상대를 확인하지 않기 때문에 위장 가능
- 완전성을 증명할 수 없기 때문에 변조 가능

SSL 등을 이용해 안전한 통신로를 확립하고 나서 그 통신로를 사용해 HTTP 통신을 한다. SSL을 조합한 HTTP를 HTTPS(HTTP Secure)나 HTTP over SSL이라 불린다.

HTTP에서는 통신 상대를 확인할 수 없지만 SSL로 상대를 확인할 수 있다. SSL은 암호화뿐만 아니라 상대를 확인하는 수단으로 증명서를 제공하고 있다. 증명서는 신뢰할 수 있는 제3자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다. 또한 증명서를 조작하는 것은 상당한 어려움이 있다. 따라서 클라이언트가 가진 증명서를 확인함으로써 통신 상대가 내가 통신하고자 하는 상대인지 아닌지를 판단할 수 있다.

HTTP에 암호화나 인증 등의 구조를 더한 것을 HTTPS라 한다. (HTTP + 통신의 암호화 + 증명서 + 완전성 보호)

HTTPS를 사용하는 통신은 웹 페이지의 로그인이나 쇼핑의 결제 화면 등에서 사용되고 있다.

### SSL

SSL에서는 공개키 암호화 방식이라 불리는 암호화 방식을 채용하고 있다. 공개키 암호화 방식은 두 개의 키가 있다.

- 비밀키(private key)
- 공개키(public key)

비밀키는 누구에게도 알려지면 안되는 키이고, 공개키는 누구에게나 알려져도 괜찮은 키이다.

서로 통신할 때는 공개키를 주고 받고, 받은 공개키를 비밀키로 복호화하여 인증할 수 있다. 하지만 이 공개키 마저도 진짜인지 가짜인지 구분할 수가 없다. 따라서 인증 기관(CA: Certificate Authority)과 그 기관이 발행하는 공개키 증명서가 이용되고 있다. 인증 기관은 신뢰할 수 있는 제3자 기관이다.
