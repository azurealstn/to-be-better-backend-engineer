# [Book] 혼자 공부하는 컴퓨터 구조와 운영체제

[혼자 공부하는 컴퓨터 구조와 운영체제](https://www.yes24.com/Product/Goods/111378840) 책은 컴퓨터 구조와 운영체제에 대해 처음 공부하는 사람이 봐도 괜찮고, 그만큼 쉽게 풀어썼다. (그래서 추천한다.)

## 목차

- [운영체제](#운영체제)
- [프로세스와 스레드](#프로세스와-스레드)
- [CPU 스케줄링](#cpu-스케줄링)
- [동기화](#동기화)

## 운영체제

컴퓨터 부품들은 전기만 공급하면 마치 마법처럼 알아서 작동하는 것이 아니다. 운영체제라는 특별한 프로그램의 지휘하에 작동한다. **운영체제**는 컴퓨터 구조를 통해 배운 컴퓨터 부품들을 관리하고, 소프트웨어 프로그램이 올바르게 실행되도록 돕는다.

> 프로그램 실행에 필요한 요소들을 **자원**이라고 하는데 모든 프로그램은 실행되기 위해 자원이 필요하다. 실행할 프로그램에 자원을 할당하고, 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램이 바로 **운영체제**이다.

운영체제는 게임, 브라우저와 같은 프로그램과 같이 메모리에 적재되어야 한다. 다만 운영체제는 매우 특별한 프로그램이기 때문에 컴퓨터가 부팅될 때 메모리 내 **커널 영역**이라는 공간에 따로 적재되어 실행된다. 그리고 커널 영역을 제외한 응용 프로그램이 적재되는 영역을 **사용자 영역**이라 한다.

운영체제는 현존하는 프로그램 중 규모가 가장 큰 프로그램이라 할 수 있는데 대표적인 운영체제인 리눅스를 구성하는 소스코드는 천만 줄이 넘는다고 한다. 그리고 운영체제의 핵심 서비스를 담당하는 부분을 **커널**이라고 한다. 즉, 커널은 운영체제의 핵심부라고 할 수 있다.

운영체제가 제공하는 서비스 중 커널에 포함되지 않는 서비스도 있는데, 대표적으로 사용자 인터페이스(UI)가 있다. 사용자 인터페이스는 윈도우의 바탕화면과 같이 사용자가 컴퓨터와 상호작용할 수 있는 통로를 말한다.

그리고 사용자 인터페이스의 종류에는 그래픽 유저 인터페이스(GUI)와 커맨드 라인 인터페이스(CLI)가 있다. 컴퓨터를 사용할 때 마우스를 이용해 다양한 프로그램을 실행할 수 있는 이유는 그래픽 유저 인터페이스가 있기 떄문이고, 커맨드 라인 인터페이스를 가지고 명령어를 입력함으로써 컴퓨터와 상호작용이 가능하다.

### 이중모드와 시스템 호출

운영체제는 사용자가 실행하는 응용 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원을 보호한다.

#### 이중 모드

운영체제의 문지기 역할을 하는 **이중 모드**는 CPU가 명령어를 실행하는 모드를 크게 사용자 모드와 커널 모드로 구분한다.

- 사용자 모드: 운영체제 서비스를 제공받을 수 없는 실행 모드
- 커널 모드: 운영체제 서비스를 제공받을 수 있는 실행 모드

#### 시스템 호출

사용자 모드로 실행되는 프로그램이 자원에 접근하는 운영체제 서비스를 제공받으려면 운영체제에 요청을 보내 커널 모드로 전환되어야 한다. 이 때 운영체제 서비스를 제공받기 위한 요청을 **시스템 호출** 혹은 시스템 콜이라 부른다. 시스템 콜은 일종의 인터럽트라 할 수 있다. (프로그램에서의 콜백을 생각하면 이해하기 쉽다.)

### OS의 핵심 서비스

운영체제의 핵심 서비스는 프로세스 관리, 자원 접근 및 할당, 파일 시스템 관리이다.

#### 프로세스 관리

실행중인 프로그램을 프로세스(process)라고 한다. 컴퓨터의 작업 관리자를 열면 수많은 프로세스들이 있고, CPU는 한번에 하나의 프로세스만 실행할 수 있기 때문에 CPU는 이 프로세스들을 조금씩 번갈아 가며 실행한다.

#### 자원 접근 및 할당

모든 프로세스는 실행을 위해 자원을 필요로하며, 운영체제는 프로세스들이 사용할 자원에 접근하고 조작함으로써 필요한 자원을 할당해준다.

#### 파일 시스템 관리

컴퓨터를 사용하면서 여러 파일을 열고, 생성하고, 삭제하고 이 파일들을 디렉토리(폴더)로 관리할 수 있는데 이는 운영체제가 해당 기능을 지원해주기 때문이다.

## 프로세스와 스레드

**프로세스**는 실행 중인 프로그램이다. 프로그램은 보조기억장치에 있는 데이터 덩어리일 뿐 프로그램만으로는 어떻게 할 수가 없다. 해당 프로그램을 메모리에 적재하고 실행하는 순간 그 프로그램이 프로세스가 된다.

### 프로세스 제어 블록

운영체제는 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고, 프로세스에 CPU를 비롯한 자원을 배분한다. 이를 위해 운영체제는 프로세스 제어 블록(PCB)을 이용한다.

프로세스 제어 블록은 프로세스와 관련된 정보를 저장하는 자료구조이다. 프로세스 제어 블록, PCB는 커널 영역에 생성된다. 수많은 프로세스들 사이에서 PCB를 이용하여 특정 프로세스를 식별하고 해당 프로세스를 처리하는데 필요한 정보를 판단한다.

> PCB는 프로세스 생성시에 만들어지고 실행이 끝나면 폐기된다.

PCB에 담기는 정보로는 아래와 같다.

- 프로세스 ID (PID): 특정 프로세스를 식별하기 위해 부여하는 고유한 번호
- 레지스터값
- 프로세스 상태
- CPU 스케줄링 정보
- 메모리 관리 정보
- 사용한 파일과 입출력장치 목록

### 문맥 교환

운영체제는 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리한다고 했다. A 프로세스를 수행하다가 B 프로세스로 변경되어 수행된다. 하지만 A 프로세스를 수행하다가 변경되면 A 프로세스의 수행을 다시 재개하기 위해 정보를 기억해야 하는데 이 정보를 **문맥 즉, 컨텍스트**라고 한다. 이 컨텍스트는 PCB 정보에 포함되어 있다.

그리고 기존 프로세스의 컨텍스트를 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 컨텍스트를 PCB로부터 복구하여 새로운 프로세스를 실행하는 것을 **문맥교환 즉, 컨텍스트 스위칭**이라고 한다. 따라서 컨텍스트 스위칭은 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리이다.

> 컨텍스트 스위칭이 자주 일어나면 프로세스는 그만큼 빨리 번갈아 가며 수행되기 때문에 우리의 눈에는 프로세스들이 동시에 실행되는 것처럼 보이는 것이다.  
> 하지만 컨텍스트 스위칭을 너무 자주 하면 오버헤드가 발생할 수 있기 때문에 컨텍스트 스위칭이 자주 일어난다고 해서 반드시 좋은 것은 아니다.

### 프로세스의 메모리 영역

프로세스는 사용자 영역에 크게 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 나뉜다.

#### 코드 영역

코드 영역은 실행할 수 있는 코드, 즉 기계어로 이루어진 명령어가 저장된다. 또한 코드 영역은 읽기 전용(read-only)이다.

#### 데이터 영역

데이터 영역은 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간이다. 이런 데이터로는 전역 변수가 대표적이다.

- 정적 할당 영역: 코드 영역과 데이터 영역
- 동적 할당 영역: 힙 영역과 스택 영역

#### 힙 영역

힙 영역은 프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장 공간이다. 할당하고 나면 언젠가는 해당 공간을 반환해야 하는데 이를 처리하지 않는다면 **메모리 누수**가 발생할 수 있다.

#### 스택 영역

스택 영역은 데이터를 일시적으로 저장하는 공간이다. 데이터 영역에 담기는 값과는 달리 잠깐 쓰다가 말 값들이 저장되는 공간이다. 대표적으로 매개변수(파라미터)와 지역변수가 있다.

### 스레드

**스레드**는 프로세스를 구성하는 실행의 흐름 단위이다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있다. 스레드를 이용하면 하나의 프로세스에서 여러 부분을 동시에 실행할 수 있다.

프로세스의 스레드들은 실행에 필요한 최소한의 정보 (프로그램 카운터를 포함한 레지스터, 스택)만을 유지한 채 **프로세스 자원을 공유하며 실행**된다.

프로세스가 실행되는 프로그램이라면 스레드는 프로세스를 구성하는 실행의 흐름 단위이다.

### 멀티 프로세스와 멀티 스레드

컴퓨터는 실행 과정에서 여러 프로세스가 동시에 실행될 수 있고, 그 프로세스를 이루는 스레드는 여러 개 있을 수 있다고 했는데, 이 때 여러 프로세스를 동시에 실행하는 것을 멀티프로세스라 하고, 여러 스레드로 프로세스를 동시에 실행하는 것을 멀티스레드라 한다.

### 프로세스와 스레드

- 프로세스끼리는 자원을 공유하지 않지만, 스레드끼리는 프로세스 내의 자원을 공유한다.
- 멀티 프로세스를 사용할 경우 프로세스 내의 코드 영역, 데이터 영역, 힙 영역, 스택 영역을 비롯한 모든 자원이 복제되어 메모리에 적재된다. 즉, 같은 프로그램을 실행하기 위해 메모리에 동일한 내용들이 중복해서 존재하기 때문에 메모리 낭비가 발생한다.
- 반면, 멀티 스레드를 사용할 경우 각기 다른 스레드 ID, 프로그램 카운터 값을 포함한 레지스터 값, 스택을 가질뿐 프로세스가 가지고 있는 자원을 서로 공유한다. 따라서 프로세스 내의 스레드는 동일한 주소 공간의 코드, 데이터, 힙 영역을 공유하고, 열린 파일과 같은 프로세스 자원을 공유한다. 이는 여러 프로세스를 병행 실행하는 것보다 메모리를 훨씬 효율적으로 사용할 수 있다. 또한 자원을 공유하기 때문에 서로 협력과 통신에 유리하다.
  - 다만, 모든 스레드는 프로세스의 자원을 공유하기 때문에 하나의 스레드에 문제가 생기면 다른 스레드도 영향을 받아 문제가 생길 수 있다.

## CPU 스케줄링

모든 프로세스는 CPU를 필요로 하고, CPU를 먼저 사용하고 싶어 한다. 이렇게 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 **CPU 스케줄링**이라고 한다. 이것이 지켜지지 않으면 당장 급하지 않은 프로세스들만 주로 실행되는 등 무질서한 상태가 발생하기 때문이다.

### 우선순위

상황에 맞게, 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 **우선순위**를 부여한다. 운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.

### 스케줄링 큐

PCB에 우선순위가 있긴 하지만, 우선순위를 찾기 위해 모든 프로세스의 PCB를 뒤적거리는 것은 비효율적이다.

그래서 운영체제는 CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 프로세스들을 모두 줄을 서서 기다릴 것을 요구한다. 이렇게 큐에다가 관리하는 것을 **스케줄링 큐**라고 한다.

### 선점형과 비선점형 스케줄링

위와 같이 스케줄링 큐를 이용하여 순서를 관리하고 있는데 갑자기 순서가 뒤에 있는 프로세스가 급한다고 하면 어떻게 처리할까? 마냥 기다려야 할까? (병원에 응급실이 왜 있는지 떠올려보자.)

**선점형 스케줄링**은 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식이다.

반면 **비선점형 스케줄링**은 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식이다.

선점형 스케줄링 방식은 어느 한 프로세스의 자원 독점을 막고 프로세스들에게 골고루 자원을 배분할 수 있는 장점이 있지만, 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다.

반면 비선점형 스케줄링 방식은 문맥 교환의 수가 선점형 스케줄링보다 적기 때문에 오버헤드가 발생할 확률이 줄어들지만, 당장 급한 자원을 사용해야 하는 상황에서도 무작정 기다리는 수 밖에 없다는 단점이 있다.

### CPU 스케줄링 알고리즘

스케줄링 큐에서 각 프로세들을 효율적으로 처리하기 위해 다양한 CPU 스케줄링 알고리즘들이 있다.

#### FCFS(First Come First Served) 스케줄링

선입 선처리라는 스케줄링은 단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식이다. 가장 공정해보이지만, 뒤에 있는 프로세스들이 대기 시간이 매우 길어질 수 있다는 점에서 부작용이 있다.

#### SJF(Shortest Job First) 스케줄링

최단 작업 우선 스케줄링은 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스들부터 실행하는 방식이다. 선점형 스케줄링의 방식이다.

#### 라운드 로빈(Round Robin) 스케줄링

라운드 로빈 스케줄링은 선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진다. 타임 슬라이스란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미한다. 즉, 정해진 타임 슬라이스만큼의 시간 동만 돌아가며 CPU를 이용하는 선점형 스케줄링이다. 따라서 라운드 로빈 스케줄링은 적절한 타임 슬라이스의 크기를 결정하는 것이 매우 중요하다.

#### SRT(Shortest Remaining Time) 스케줄링

최소 자연 시간 우선 스케줄링은 SJF 스케줄링과 라운드 로빈 스케줄링을 합친 스케줄링 방식이다. 즉, 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스는 남아있는 작업 시간이 가장 짧은 프로세스가 선택된다.

#### 우선순위(Priority) 스케줄링

우선순위 스케줄링은 프로세스들에게 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 방식이다.

#### 다단계 피드백 큐 스케줄링

다단계 피드백 큐 스케줄링은 어떤 프로세스의 CPU 이용 시간이 길면 낮은 우선순위 큐로 이동시키고, 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다린다면 높은 우선순위 큐로 이동시킬 수 있는 방식이다. 다단계 피드백 큐 스케줄링은 가장 일반적인 CPU 스케줄링 알고리즘으로 알려져 있다.

## 동기화

동시다발적으로 실행되는 프로세스들은 공동의 목적을 올바르게 수행하기 위해 서로 협력하며 영향을 주고 받기도 한다. 이렇게 협력하여 실행되는 프로세스들은 실행 순서와 자원의 일관성을 보장해야 하기에 반드시 **동기화**되어야 한다.

여기서 동기화 되려면 아래의 조건을 만족해야 한다.

- 실행 순서 제어: 프로세스를 올바른 순서대로 실행하기
- 상호 배제: 동시에 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하기

> 상호 배제는 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘이다.

### 공유자원과 임계구역

동시에 실행되는 프로세스들은 전역 변수라는 공동의 자원을 두고 작업한다. 이러한 자원을 공유자원이라 하고, 공유 자원은 전역변수, 파일, 입출력장치, 보조기억장치가 될 수 있다.

공유자원 중에는 두 개 이상의 프로세스를 동시에 실행하면 문제가 발생할 수 있는데 이렇게 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역을 **임계 구역**이라고 한다. 두 개 이상의 프로세스가 임계 구역에 진입하고자 하면 둘 중 하나는 대기해야 한다.

잘못된 실행으로 인해 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우도 있는데, 이를 레이스 컨디션(race condition)이라고 한다.

> 상호 배제는 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다.

### 동기화 기법

프로세스의 동기화는 어떻게 이루어질까? 동기화를 위한 대표적인 도구인 뮤텍스 락, 세마토, 모니터가 있다.

#### 뮤텍스 락

뮤텍스 락은 동시에 접근해서는 안되는 자원에 동시에 접근하지 않도록 만드는 도구, 다시 말해 상호 배제를 위한 동기화 도구이다. 뮤텍스 락의 매우 단순한 형태는 하나의 전역 변수와 두 개의 함수로 구현할 수 있다.

- 자물쇠 역할: 프로세스들이 공유하는 전역 변수 lock
- 임계 구역을 잠그는 역할: acquire 함수
- 임계 구역의 잠금을 해제하는 역할: release 함수

acquire 함수를 호출하여 전역 변수 lock을 걸어주고, 수행이 종료되면 release 함수를 호출하여 전역 변수 lock을 풀어준다.

#### 세마포

세마포는 뮤텍스 락과 비슷하지만, 조금 더 일반화된 방식의 동기화 도구이다. 뮤텍스 락은 하나의 공유자원에 접근하는 프로세스를 상정한 방식이다.

공유자원이 여러 개 있을 경우 (각 공유 자원에는 하나의 프로세스만 진입이 가능할지라도) 여러 개의 프로세스가 각각 공유자원에 접근이 가능해야 한다. 이렇게 공유자원이 여러 개 있는 상황에서도 적용이 가능한 도익화 도구를 세마포라 한다.

세마포 역시 매우 단순한 형태로 하나의 전역 변수와 두 개의 함수로 구현할 수 있다.

- 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유자원의 개수)를 나타내는 전역변수 S
- 임계구역에 들어가도 좋은지, 기다려야 할지를 알려주는 wait 함수
- 임계구역 앞에서 기다리는 프로세스에 '이제 가도 좋다'고 신호를 주는 signal 함수

전역변수 S를 통해 임계 구역에 진입할 수 있는 프로세스의 개수를 확인하여 진입할 수 있으면 signal 함수를 사용하고, 진입할 수 없고, 기다려야 한다면 wait 함수를 사용한다.

여기서 signal 함수를 호출하면 전역변수 S의 개수를 하나 증가시키고(진입할 수 있으므로), wait 함수 함수를 호출하면 전역변수 S의 개수를 하나 감소시킨다. (진입할 수 없으므로)

#### 모니터

세마포는 훌륭한 프로세스 동기화 도구이지만, 매번 임계구역에 앞뒤로 일일이 wait와 signal 함수를 명시하는 것은 번거로운 일이다. 따라서 최근에 모니터 라는 동기화 도구가 생겼다.

모니터는 공유자원을 다루는 인터페이스에 접근하기 위한 큐(모니터에 접근하기 위한 큐)를 만들고, 모니터 안에 항상 하나의 프로세스만 들어오도록 하여 상호 배제를 위한 동기화를 제공한다.

특정 조건을 바탕으로 프로세스를 실행하고 일시 중단하기 위해 모니터는 **조건 변수**를 사용하는데, 조건 변수는 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수이다.

- 특정 프로세스가 아직 실행될 조건이 되지 않았을 때, wait 함수를 통해 실행을 중단
- 특정 프로세스가 실행될 조건이 충족되었을 때, signal 함수를 통해 실행을 재개
