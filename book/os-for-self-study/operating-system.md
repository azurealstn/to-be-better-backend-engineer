# [Book] 혼자 공부하는 컴퓨터 구조와 운영체제

[혼자 공부하는 컴퓨터 구조와 운영체제](https://www.yes24.com/Product/Goods/111378840) 책은 컴퓨터 구조와 운영체제에 대해 처음 공부하는 사람이 봐도 괜찮고, 그만큼 쉽게 풀어썼다. (그래서 추천한다.)

## 목차

- [운영체제](#운영체제)
- [프로세스와 스레드](#프로세스와-스레드)
- [CPU 스케줄링](#cpu-스케줄링)
- [동기화](#동기화)
- [교착상태](#교착상태)
- [가상 메모리](#가상-메모리)

## 운영체제

컴퓨터 부품들은 전기만 공급하면 마치 마법처럼 알아서 작동하는 것이 아니다. 운영체제라는 특별한 프로그램의 지휘하에 작동한다. **운영체제**는 컴퓨터 구조를 통해 배운 컴퓨터 부품들을 관리하고, 소프트웨어 프로그램이 올바르게 실행되도록 돕는다.

> 프로그램 실행에 필요한 요소들을 **자원**이라고 하는데 모든 프로그램은 실행되기 위해 자원이 필요하다. 실행할 프로그램에 자원을 할당하고, 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램이 바로 **운영체제**이다.

운영체제는 게임, 브라우저와 같은 프로그램과 같이 메모리에 적재되어야 한다. 다만 운영체제는 매우 특별한 프로그램이기 때문에 컴퓨터가 부팅될 때 메모리 내 **커널 영역**이라는 공간에 따로 적재되어 실행된다. 그리고 커널 영역을 제외한 응용 프로그램이 적재되는 영역을 **사용자 영역**이라 한다.

운영체제는 현존하는 프로그램 중 규모가 가장 큰 프로그램이라 할 수 있는데 대표적인 운영체제인 리눅스를 구성하는 소스코드는 천만 줄이 넘는다고 한다. 그리고 운영체제의 핵심 서비스를 담당하는 부분을 **커널**이라고 한다. 즉, 커널은 운영체제의 핵심부라고 할 수 있다.

운영체제가 제공하는 서비스 중 커널에 포함되지 않는 서비스도 있는데, 대표적으로 사용자 인터페이스(UI)가 있다. 사용자 인터페이스는 윈도우의 바탕화면과 같이 사용자가 컴퓨터와 상호작용할 수 있는 통로를 말한다.

그리고 사용자 인터페이스의 종류에는 그래픽 유저 인터페이스(GUI)와 커맨드 라인 인터페이스(CLI)가 있다. 컴퓨터를 사용할 때 마우스를 이용해 다양한 프로그램을 실행할 수 있는 이유는 그래픽 유저 인터페이스가 있기 떄문이고, 커맨드 라인 인터페이스를 가지고 명령어를 입력함으로써 컴퓨터와 상호작용이 가능하다.

### 이중모드와 시스템 호출

운영체제는 사용자가 실행하는 응용 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원을 보호한다.

#### 이중 모드

운영체제의 문지기 역할을 하는 **이중 모드**는 CPU가 명령어를 실행하는 모드를 크게 사용자 모드와 커널 모드로 구분한다.

- 사용자 모드: 운영체제 서비스를 제공받을 수 없는 실행 모드
- 커널 모드: 운영체제 서비스를 제공받을 수 있는 실행 모드

#### 시스템 호출

사용자 모드로 실행되는 프로그램이 자원에 접근하는 운영체제 서비스를 제공받으려면 운영체제에 요청을 보내 커널 모드로 전환되어야 한다. 이 때 운영체제 서비스를 제공받기 위한 요청을 **시스템 호출** 혹은 시스템 콜이라 부른다. 시스템 콜은 일종의 인터럽트라 할 수 있다. (프로그램에서의 콜백을 생각하면 이해하기 쉽다.)

### OS의 핵심 서비스

운영체제의 핵심 서비스는 프로세스 관리, 자원 접근 및 할당, 파일 시스템 관리이다.

#### 프로세스 관리

실행중인 프로그램을 프로세스(process)라고 한다. 컴퓨터의 작업 관리자를 열면 수많은 프로세스들이 있고, CPU는 한번에 하나의 프로세스만 실행할 수 있기 때문에 CPU는 이 프로세스들을 조금씩 번갈아 가며 실행한다.

#### 자원 접근 및 할당

모든 프로세스는 실행을 위해 자원을 필요로하며, 운영체제는 프로세스들이 사용할 자원에 접근하고 조작함으로써 필요한 자원을 할당해준다.

#### 파일 시스템 관리

컴퓨터를 사용하면서 여러 파일을 열고, 생성하고, 삭제하고 이 파일들을 디렉토리(폴더)로 관리할 수 있는데 이는 운영체제가 해당 기능을 지원해주기 때문이다.

## 프로세스와 스레드

**프로세스**는 실행 중인 프로그램이다. 프로그램은 보조기억장치에 있는 데이터 덩어리일 뿐 프로그램만으로는 어떻게 할 수가 없다. 해당 프로그램을 메모리에 적재하고 실행하는 순간 그 프로그램이 프로세스가 된다.

### 프로세스 제어 블록

운영체제는 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고, 프로세스에 CPU를 비롯한 자원을 배분한다. 이를 위해 운영체제는 프로세스 제어 블록(PCB)을 이용한다.

프로세스 제어 블록은 프로세스와 관련된 정보를 저장하는 자료구조이다. 프로세스 제어 블록, PCB는 커널 영역에 생성된다. 수많은 프로세스들 사이에서 PCB를 이용하여 특정 프로세스를 식별하고 해당 프로세스를 처리하는데 필요한 정보를 판단한다.

> PCB는 프로세스 생성시에 만들어지고 실행이 끝나면 폐기된다.

PCB에 담기는 정보로는 아래와 같다.

- 프로세스 ID (PID): 특정 프로세스를 식별하기 위해 부여하는 고유한 번호
- 레지스터값
- 프로세스 상태
- CPU 스케줄링 정보
- 메모리 관리 정보
- 사용한 파일과 입출력장치 목록

### 문맥 교환

운영체제는 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리한다고 했다. A 프로세스를 수행하다가 B 프로세스로 변경되어 수행된다. 하지만 A 프로세스를 수행하다가 변경되면 A 프로세스의 수행을 다시 재개하기 위해 정보를 기억해야 하는데 이 정보를 **문맥 즉, 컨텍스트**라고 한다. 이 컨텍스트는 PCB 정보에 포함되어 있다.

그리고 기존 프로세스의 컨텍스트를 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 컨텍스트를 PCB로부터 복구하여 새로운 프로세스를 실행하는 것을 **문맥교환 즉, 컨텍스트 스위칭**이라고 한다. 따라서 컨텍스트 스위칭은 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리이다.

> 컨텍스트 스위칭이 자주 일어나면 프로세스는 그만큼 빨리 번갈아 가며 수행되기 때문에 우리의 눈에는 프로세스들이 동시에 실행되는 것처럼 보이는 것이다.  
> 하지만 컨텍스트 스위칭을 너무 자주 하면 오버헤드가 발생할 수 있기 때문에 컨텍스트 스위칭이 자주 일어난다고 해서 반드시 좋은 것은 아니다.

### 프로세스의 메모리 영역

프로세스는 사용자 영역에 크게 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 나뉜다.

#### 코드 영역

코드 영역은 실행할 수 있는 코드, 즉 기계어로 이루어진 명령어가 저장된다. 또한 코드 영역은 읽기 전용(read-only)이다.

#### 데이터 영역

데이터 영역은 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간이다. 이런 데이터로는 전역 변수가 대표적이다.

- 정적 할당 영역: 코드 영역과 데이터 영역
- 동적 할당 영역: 힙 영역과 스택 영역

#### 힙 영역

힙 영역은 프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장 공간이다. 할당하고 나면 언젠가는 해당 공간을 반환해야 하는데 이를 처리하지 않는다면 **메모리 누수**가 발생할 수 있다.

#### 스택 영역

스택 영역은 데이터를 일시적으로 저장하는 공간이다. 데이터 영역에 담기는 값과는 달리 잠깐 쓰다가 말 값들이 저장되는 공간이다. 대표적으로 매개변수(파라미터)와 지역변수가 있다.

### 스레드

**스레드**는 프로세스를 구성하는 실행의 흐름 단위이다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있다. 스레드를 이용하면 하나의 프로세스에서 여러 부분을 동시에 실행할 수 있다.

프로세스의 스레드들은 실행에 필요한 최소한의 정보 (프로그램 카운터를 포함한 레지스터, 스택)만을 유지한 채 **프로세스 자원을 공유하며 실행**된다.

프로세스가 실행되는 프로그램이라면 스레드는 프로세스를 구성하는 실행의 흐름 단위이다.

### 멀티 프로세스와 멀티 스레드

컴퓨터는 실행 과정에서 여러 프로세스가 동시에 실행될 수 있고, 그 프로세스를 이루는 스레드는 여러 개 있을 수 있다고 했는데, 이 때 여러 프로세스를 동시에 실행하는 것을 멀티프로세스라 하고, 여러 스레드로 프로세스를 동시에 실행하는 것을 멀티스레드라 한다.

### 프로세스와 스레드

- 프로세스끼리는 자원을 공유하지 않지만, 스레드끼리는 프로세스 내의 자원을 공유한다.
- 멀티 프로세스를 사용할 경우 프로세스 내의 코드 영역, 데이터 영역, 힙 영역, 스택 영역을 비롯한 모든 자원이 복제되어 메모리에 적재된다. 즉, 같은 프로그램을 실행하기 위해 메모리에 동일한 내용들이 중복해서 존재하기 때문에 메모리 낭비가 발생한다.
- 반면, 멀티 스레드를 사용할 경우 각기 다른 스레드 ID, 프로그램 카운터 값을 포함한 레지스터 값, 스택을 가질뿐 프로세스가 가지고 있는 자원을 서로 공유한다. 따라서 프로세스 내의 스레드는 동일한 주소 공간의 코드, 데이터, 힙 영역을 공유하고, 열린 파일과 같은 프로세스 자원을 공유한다. 이는 여러 프로세스를 병행 실행하는 것보다 메모리를 훨씬 효율적으로 사용할 수 있다. 또한 자원을 공유하기 때문에 서로 협력과 통신에 유리하다.
  - 다만, 모든 스레드는 프로세스의 자원을 공유하기 때문에 하나의 스레드에 문제가 생기면 다른 스레드도 영향을 받아 문제가 생길 수 있다.

## CPU 스케줄링

모든 프로세스는 CPU를 필요로 하고, CPU를 먼저 사용하고 싶어 한다. 이렇게 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 **CPU 스케줄링**이라고 한다. 이것이 지켜지지 않으면 당장 급하지 않은 프로세스들만 주로 실행되는 등 무질서한 상태가 발생하기 때문이다.

### 우선순위

상황에 맞게, 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 **우선순위**를 부여한다. 운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.

### 스케줄링 큐

PCB에 우선순위가 있긴 하지만, 우선순위를 찾기 위해 모든 프로세스의 PCB를 뒤적거리는 것은 비효율적이다.

그래서 운영체제는 CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 프로세스들을 모두 줄을 서서 기다릴 것을 요구한다. 이렇게 큐에다가 관리하는 것을 **스케줄링 큐**라고 한다.

### 선점형과 비선점형 스케줄링

위와 같이 스케줄링 큐를 이용하여 순서를 관리하고 있는데 갑자기 순서가 뒤에 있는 프로세스가 급한다고 하면 어떻게 처리할까? 마냥 기다려야 할까? (병원에 응급실이 왜 있는지 떠올려보자.)

**선점형 스케줄링**은 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식이다.

반면 **비선점형 스케줄링**은 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식이다.

선점형 스케줄링 방식은 어느 한 프로세스의 자원 독점을 막고 프로세스들에게 골고루 자원을 배분할 수 있는 장점이 있지만, 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다.

반면 비선점형 스케줄링 방식은 문맥 교환의 수가 선점형 스케줄링보다 적기 때문에 오버헤드가 발생할 확률이 줄어들지만, 당장 급한 자원을 사용해야 하는 상황에서도 무작정 기다리는 수 밖에 없다는 단점이 있다.

### CPU 스케줄링 알고리즘

스케줄링 큐에서 각 프로세들을 효율적으로 처리하기 위해 다양한 CPU 스케줄링 알고리즘들이 있다.

#### FCFS(First Come First Served) 스케줄링

선입 선처리라는 스케줄링은 단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식이다. 가장 공정해보이지만, 뒤에 있는 프로세스들이 대기 시간이 매우 길어질 수 있다는 점에서 부작용이 있다.

#### SJF(Shortest Job First) 스케줄링

최단 작업 우선 스케줄링은 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스들부터 실행하는 방식이다. 선점형 스케줄링의 방식이다.

#### 라운드 로빈(Round Robin) 스케줄링

라운드 로빈 스케줄링은 선입 선처리 스케줄링에 타임 슬라이스라는 개념이 더해진다. 타임 슬라이스란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미한다. 즉, 정해진 타임 슬라이스만큼의 시간 동만 돌아가며 CPU를 이용하는 선점형 스케줄링이다. 따라서 라운드 로빈 스케줄링은 적절한 타임 슬라이스의 크기를 결정하는 것이 매우 중요하다.

#### SRT(Shortest Remaining Time) 스케줄링

최소 자연 시간 우선 스케줄링은 SJF 스케줄링과 라운드 로빈 스케줄링을 합친 스케줄링 방식이다. 즉, 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스는 남아있는 작업 시간이 가장 짧은 프로세스가 선택된다.

#### 우선순위(Priority) 스케줄링

우선순위 스케줄링은 프로세스들에게 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 방식이다.

#### 다단계 피드백 큐 스케줄링

다단계 피드백 큐 스케줄링은 어떤 프로세스의 CPU 이용 시간이 길면 낮은 우선순위 큐로 이동시키고, 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다린다면 높은 우선순위 큐로 이동시킬 수 있는 방식이다. 다단계 피드백 큐 스케줄링은 가장 일반적인 CPU 스케줄링 알고리즘으로 알려져 있다.

## 동기화

동시다발적으로 실행되는 프로세스들은 공동의 목적을 올바르게 수행하기 위해 서로 협력하며 영향을 주고 받기도 한다. 이렇게 협력하여 실행되는 프로세스들은 실행 순서와 자원의 일관성을 보장해야 하기에 반드시 **동기화**되어야 한다.

여기서 동기화 되려면 아래의 조건을 만족해야 한다.

- 실행 순서 제어: 프로세스를 올바른 순서대로 실행하기
- 상호 배제: 동시에 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하기

> 상호 배제는 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘이다.

### 공유자원과 임계구역

동시에 실행되는 프로세스들은 전역 변수라는 공동의 자원을 두고 작업한다. 이러한 자원을 공유자원이라 하고, 공유 자원은 전역변수, 파일, 입출력장치, 보조기억장치가 될 수 있다.

공유자원 중에는 두 개 이상의 프로세스를 동시에 실행하면 문제가 발생할 수 있는데 이렇게 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역을 **임계 구역**이라고 한다. 두 개 이상의 프로세스가 임계 구역에 진입하고자 하면 둘 중 하나는 대기해야 한다.

잘못된 실행으로 인해 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생하는 경우도 있는데, 이를 레이스 컨디션(race condition)이라고 한다.

> 상호 배제는 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다.

### 동기화 기법

프로세스의 동기화는 어떻게 이루어질까? 동기화를 위한 대표적인 도구인 뮤텍스 락, 세마토, 모니터가 있다.

#### 뮤텍스 락

뮤텍스 락은 동시에 접근해서는 안되는 자원에 동시에 접근하지 않도록 만드는 도구, 다시 말해 상호 배제를 위한 동기화 도구이다. 뮤텍스 락의 매우 단순한 형태는 하나의 전역 변수와 두 개의 함수로 구현할 수 있다.

- 자물쇠 역할: 프로세스들이 공유하는 전역 변수 lock
- 임계 구역을 잠그는 역할: acquire 함수
- 임계 구역의 잠금을 해제하는 역할: release 함수

acquire 함수를 호출하여 전역 변수 lock을 걸어주고, 수행이 종료되면 release 함수를 호출하여 전역 변수 lock을 풀어준다.

#### 세마포

세마포는 뮤텍스 락과 비슷하지만, 조금 더 일반화된 방식의 동기화 도구이다. 뮤텍스 락은 하나의 공유자원에 접근하는 프로세스를 상정한 방식이다.

공유자원이 여러 개 있을 경우 (각 공유 자원에는 하나의 프로세스만 진입이 가능할지라도) 여러 개의 프로세스가 각각 공유자원에 접근이 가능해야 한다. 이렇게 공유자원이 여러 개 있는 상황에서도 적용이 가능한 도익화 도구를 세마포라 한다.

세마포 역시 매우 단순한 형태로 하나의 전역 변수와 두 개의 함수로 구현할 수 있다.

- 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유자원의 개수)를 나타내는 전역변수 S
- 임계구역에 들어가도 좋은지, 기다려야 할지를 알려주는 wait 함수
- 임계구역 앞에서 기다리는 프로세스에 '이제 가도 좋다'고 신호를 주는 signal 함수

전역변수 S를 통해 임계 구역에 진입할 수 있는 프로세스의 개수를 확인하여 진입할 수 있으면 signal 함수를 사용하고, 진입할 수 없고, 기다려야 한다면 wait 함수를 사용한다.

여기서 signal 함수를 호출하면 전역변수 S의 개수를 하나 증가시키고(진입할 수 있으므로), wait 함수 함수를 호출하면 전역변수 S의 개수를 하나 감소시킨다. (진입할 수 없으므로)

#### 모니터

세마포는 훌륭한 프로세스 동기화 도구이지만, 매번 임계구역에 앞뒤로 일일이 wait와 signal 함수를 명시하는 것은 번거로운 일이다. 따라서 최근에 모니터 라는 동기화 도구가 생겼다.

모니터는 공유자원을 다루는 인터페이스에 접근하기 위한 큐(모니터에 접근하기 위한 큐)를 만들고, 모니터 안에 항상 하나의 프로세스만 들어오도록 하여 상호 배제를 위한 동기화를 제공한다.

특정 조건을 바탕으로 프로세스를 실행하고 일시 중단하기 위해 모니터는 **조건 변수**를 사용하는데, 조건 변수는 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수이다.

- 특정 프로세스가 아직 실행될 조건이 되지 않았을 때, wait 함수를 통해 실행을 중단
- 특정 프로세스가 실행될 조건이 충족되었을 때, signal 함수를 통해 실행을 재개

## 교착상태

프로세스를 실행하기 위해서는 자원이 필요한데, 두 개 이상의 프로세스가 각자 가지고 있는 자원을 무작정 기다린다면 그 어떤 프로세스도 더 이상 진행할 수 없는 **교착 상태**가 된다.

뮤텍스 락에서도 교착 상태가 발생할 수 있다. 한 번에 하나의 프로세스 혹은 스레드만 접근할 수 있다.(임계 구역) 프로세스 A는 임계 구역 진입 전 lock1을 잠그고, 프로세스 B는 임계 구역 진입 전 lock2를 잠갔다고 가정해보겠다. 만일 프로세스 A는 lock2가 풀리길 기다리고, 프로세스 B는 lock1이 풀리길 기다린다면 교착상태가 발생하는 것이다.

> 교착 상태를 표현할 수 있는 그래프가 있는데 **자원 할당 그래프**이다. 자원 할당 그래프가 원의 형태를 띄운다면 교착 상태인 것이다.

### 교착 상태 발생 조건

- 상호 배체: 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없을 때, 즉 상호 배제 상황에서 교착상태가 발생할 수 있다.
- 점유와 대기: 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다리는 상태
- 비선점: 비선점 자원은 그 자원을 프로세스의 작업이 끝나야만 비로소 사용할 수 있다. 즉, 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못했기 때문에 교착상태가 발생한다.
- 원형대기: 프로세스들이 원의 형태로 자원을 대기하는 것

### 교착상태 해결방법

운영체제는 애초에 교착 상태가 일어나지 않도록 교착 상태 발생 조건에 부합하지 않게 자원을 분배하여 교착상태를 **예방**할 수 있고, 교착상태가 발생하지 않을 정도로 조금씩 자원을 할당하다가 교착상태의 위험이 있다면 할당하지 않는 방식으로 교착상태를 **회피**할 수도 있다. 그리고 자원을 제약없이 할당하다가 교착상태가 **검출**되면 교착상태를 **회복**하는 방법을 취할 수도 있다.

#### 예방

- **상호배제**를 없애 모든 자원을 공유 가능하게 만든다.
- **점유와 대기**를 없애서 운영체제는 특정 프로세스에 자원을 모두 할당하거나 아예 할당하지 않는 방식으로 배분한다.
- **비선점 조건**을 없애 자원을 이용중인 프로세스로부터 해당 자원을 빼앗을 수 있다.
- **원형 대기**를 없애 모든 자원에 번호를 붙이고, 오름차순으로 자원을 할당한다.

#### 회피

교착상태 회피는 교착상태가 발생하지 않을 정도로만 조심조심 자원을 할당하는 방식이다. 교착상태 회피 방식에서는 교착상태를 한정된 자원의 무분별한 할당으로 인해 발생하는 문제로 간주한다. 따라서 프로세스들에 배분할 수 있는 자원의 양을 고려하여 교착상태가 발생하지 않을 정도의 양만큼만 자원을 배분하는 방법이 교착상태 회피이다.

#### 검출 후 회복

교착상태 검출 후 회복은 교착상태 발생을 안정하고 사후에 조치하는 방식이다. 운영체제는 프로세스들이 자원을 요구할 때마다 그때그때 모두 할당하며, 교착상태 발생 여부를 주기적으로 검사한다.

- 교착상태가 해결될 때까지 다른 프로세스로부터 자원을 강제로 빼앗고 한 프로세스에 할당하는 방식인 **선점을 통한 회복**
- 운영체제는 교착상태에 놓인 프로세스를 모두 강제 종료할 수 있는데, 이처럼 프로세스 강제로 종료하는 방식인 **프로세스 강제 종료를 통한 회복**

## 가상 메모리

가상 메모리는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.

### 스와핑

먼저 기본적인 메모리 관리 기법인 스와핑에 대한 개념을 살펴보겠다.

메모리에 적재된 프로세스들 중에는 현재 실행되지 않는 프로세스가 있을 수 있다. 이러한 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 해서 생긴 메모리 상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식을 **스와핑**이라고 한다.

이 때 프로세스들이 쫓겨나는 보조기억장치의 일부 영역을 **스왑영역**이라고 부른다. 그리고 현재 실행되지 않는 프로세스가 메모리에서 스왑영역으로 옮겨지는 것을 **스왑아웃**, 반대로 스왑영역에 있던 프로세스가 다시 메모리로 옮겨오는 것을 **스왑 인**이라 한다.

> 스와핑은 메모리에서 사용되지 않는 일부 프로세스를 보조기억장치로 내보내고 실행할 프로세스를 메모리로 들여보내는 메모리 관리 기법이다.

### 메모리 할당

프로세스는 메모리 내의 빈 공간에 적재되어야 한다. 만약 빈 공간이 여러 개 있다면 어디에 배치하는 것이 좋을까?

이렇게 비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식에는 대표적으로 **최초적합, 최적적합, 최악적합**이 있다.

#### 최초 적합

최초적합은 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식이다.

#### 최적적합

최적적합은 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식이다.

#### 최악적합

최악적합은 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식이다.

### 외부 단편화

위에서 설명한 부분은 프로세스를 메모리에 연속적으로 배치하는 연속 메모리 할당인데, 이는 효율적이지 않다. 그 이유는 **외부 단편화**라는 문제를 내포하고 있기 때문이다.

프로세스가 종료되면 중간중간에 빈 공간이 생긴다. 프로세스 바깥에 생기는 이러한 빈 공간들은 분명 빈 공간이지만 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고, 결국 메모리 낭비로 이어진다. 이러한 현상은 **외부 단편화**라고 한다.

메모리 용량도 크고 적재되는 프로세스도 많으면 외부 단편화로 인해 낭비되는 공간은 매우 크다. 따라서 외부 단편화 문제는 반드시 해결해야 한다.

#### 압축

외부 단편화를 해결할 수 있는 대표적인 방안으로 메모리 **압축**이 있다. 메모리 조각 모음이라고도 부른다. 압축은 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 메모리 내에 저장된 프로세스를 적당히 재배치시켜 놓는다.

하지만 작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야하고, 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기하며, 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 명확한 방법을 결정하기 어렵다.

### 페이징

그래서 압축 대신 오늘날까지 외부 단편화를 해결하는데 사용되는 것이 **페이징**이다.

가상 메모리는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다. 이를 가능케 하는 가상 메모리 관리 기법에는 크게 **페이징**과 **세그멘테이션**이 있다.

메모리와 프로세스를 일정한 단위로 자르고, 이를 메모리에 불연속적으로도 할당할 수만 있다면 외부 단편화는 발생하지 않는다. 페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.

> 프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만을 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있다. 이와 같은 방식을 통해 물리 메모리보다 더 큰 프로세스를 실행할 수 있다.

### 페이지 테이블

하지만 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수 없다. 이를 해결하기 위해 페이징 시스템은 프로세스가 비록 물리 주소에 불연속적으로 배치되더라도 논리 주소에는 연속적으로 배치되도록 **페이지 테이블**을 이용한다.

페이지 테이블은 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표이다. CPU로 하여금 페이지 번호만 보고 해당 페이지가 적재된 프레임을 찾을 수 있게 한다. (HashMap을 생각해보자.)

### 내부 단편화

> 페이징은 내부 단편화 문제를 해결할 수 있지만 **내부 단편화** 문제를 야기할 수 있다. 페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 크기 단위로 자르는데, 모든 프로세스가 이 페이지 크기에 딱 맞게 잘리는 것은 아니다. 이처럼 메모리 낭비를 내부 단편화라 한다. 따라서 페이지의 크기를 너무 크지 않게 적정한 크기를 정하는 것이 매우 중요하다.

### 페이지 교체 알고리즘

**요구 페이징**이란 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법을 말한다.

요구 페이징 기법으로 페이지들을 적재하다보면 언젠가 메모리가 가득 차게 된다. 이 때는 당장 실행에 필요한 페이지를 적재하기 위해 메모리에 적재된 페이지를 보조기억장치로 내보내야 한다. 이처럼 메모리에 적재된 많고 많은 페이지 중 어떤 페이지를 내보내는 것이 최선일지 결정하는 것이 **페이지 교체 알고리즘**이다.

#### FIFO 페이지 교체 알고리즘

가장 단순한 방법으로, 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식이다. 하지만 프로그램 실행 내내 사용될 내용을 포함하고 있을 수도 있기 때문에 메모리에 먼저 적재되었다고 해서 내쫓아서는 안된다.

#### 최적 페이지 교체 알고리즘

최적 페이지 교체 알고리즘은 CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘이다. 보조기억장치로 내보내야할 페이지는 사용빈도가 가장 낮은 페이지, 앞으로 사용빈도가 가장 낮은 페이지를 교체하는 알고리즘이다.

#### LRU 페이지 교체 알고리즘

LRU 페이지 교체 알고리즘은 최근에 사용되지 않은 페이지는 앞으로도 사용되지 않을 것이라는 아이디어를 토대로 만들어진 알고리즘이다. 페이지마다 마지막으로 사용한 시간을 토대로 최근에 가장 사용이 적었던 페이지를 교체한다.
