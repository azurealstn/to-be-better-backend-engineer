## 검증 헤더와 조건부 요청

캐시 유효 시간이 초과해서 서버에 다시 요청하면 두 가지 상황이 생긴다.

1. 서버에서 기존 데이터를 변경함
2. 서버에서 기존 데이터를 변경하지 않음

- 1번의 경우 데이터가 변경되었으므로, 다시 다운로드 받으면 된다.
- 하지만 2번의 경우 데이터가 변경되지 않아서 기존 데이터와 같다. 그런데도 다시 다운로드 받을 필요가 있을까?

### 검증 헤더와 조건부 요청 활용1

2번의 문제를 해결하기 위해 검증 헤더와 조건부 요청이 생긴다.

클라이언트가 요청하면 서버에서는 `Last-Modifed`라는 헤더를 담아서 응답한다.

- Last-Modified: Tue, 27 Feb 2024 16:23:53 GMT
- 마지막으로 수정된 날짜

여기서 캐시 유효 시간이 초과되고, 클라이언트가 다시 요청하게 되면 요청시 다음 헤더(`if-modified-since`)를 추가해서 전송하게 된다.

- if-modified-since: Tue, 27 Feb 2024 16:23:53 GMT
- 해당 날짜 이후에 데이터가 수정되었는지?

`Last-Modifed`의 값과 `if-modified-since` 값을 비교해서 날짜 값이 같으면 서버에서는 `304 Not Modified`라는 상태코드 메시지를 보낸다. 여기서 중요한 점은 HTTP 메시지 바디가 비어있다. 그 이유는 기존 데이터가 수정되지 않았기 때문에 굳이 바디에 데이터를 보낼 필요가 없는 것이다.

그리고나서 캐시를 다시 새로 갱신하게 된다.

- `Last-Modifed`를 검증 헤더, `if-modified-since`를 조건부 요청이라고 부른다.
- 검증 헤더는 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터이고, 조건부 요청 헤더는 검증 헤더로 조건에 따른 분기 데이터이다.
- 조건이 만족하면 `200 OK`를, 만족하지 않으면 `304 Not Modified`를 반환한다.
- `200 OK`는 변경이 되었으므로 HTTP 메시지 바디를 포함하여 전송한다. `304 Not Modified`는 변경되지 않았으므로 HTTP 메시지 바디를 포함하지 않는다.

### 검증 헤더와 조건부 요청 활용2

또다른 검증 헤더와 조건부 요청은 `ETag`와 `If-None-Match`가 있다.

ETag 응답 헤더는 강한 검증으로써 단순히 값을 비교하여 같으면 유지하고, 다르면 새로 갱신한다.

- 서버에서 `ETag` 응답 헤더를 보내면 클라이언트는 캐시에 ETag를 저장한다.
- 클라이언트는 요청시 캐시에 저장된 ETag를 함께 전송한다. 이 때 헤더에는 `If-None-Match`라는 요청 헤더를 보낸다.
- 서버는 클라이언트가 보낸 `If-None-Match`값을 확인하여 `ETag` 값을 비교한다.
- 비교하여 같으면 `304 Not Modified`를 다르면 `200 OK`를 반환하여 새로 갱신한다.
- `ETag`를 검증 헤더, `If-None-Match`를 조건부 요청이라 한다.
- 이를 통해 캐시 제어 로직을 서버에서 완전히 관리하게 된다.

## References

- [모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC#)
