# 추상 클래스와 인터페이스

## 추상 클래스

```java
// 추상 클래스
abstract class Data {
}
public class Main {
    public static void main(String[] args) {
//        Data data = new Data(); // 컴파일 에러 발생!

    }
}
```

부모 클래스는 제공하지만, 실제 생성되면 안되는 클래스를 추상 클래스라 한다. (인스턴스를 생성할 수 없다.) 추상 클래스는 이름 그대로 추상적인 개념을 제공하는 클래스이다. 따라서 실체인 인스턴스가 존재하지 않는다. 대신에 상속을 목적으로 사용되고, 부모 클래스 역할을 담당한다.

### 추상 메서드

```java
// 추상 클래스
abstract class Data {
    public abstract void show();
}
```

- 추상 메서드는 선언할 때 메서드 앞에 추상이라는 의미의 `abstract` 키워드를 붙여주면 된다.
- **추상 메서드가 하나라도 있는 클래스는 추상 클래스로 선언해야 한다.**
  - 그렇지 않으면 컴파일 오류가 발생한다.
  - 추상 메서드는 메서드 바디가 없다. 따라서 작동하지 않는 메서드를 가진 불완전한 클래스로 볼 수 있다. 따라서 직접 생성하지 못하도록 추상 클래스로 선언해야 한다.
- **추상 메서드는 상속 받는 자식 클래스가 반드시 오버라이딩 해서 사용해야 한다.**
  - 그렇지 않으면 컴파일 오류가 발생한다.
  - 추상 메서드는 자식 클래스가 반드시 오버라이딩 해야 하기 때문에 메서드 바디 부분이 없다. 바디 부분을 만들면 컴파일 오류가 발생한다.
  - 오버라이딩 하지 않으면 자식도 추상 클래스가 되어야 한다.

## 인터페이스

자바는 순수 추상 클래스를 더 편리하게 사용할 수 있는 인터페이스라는 기능을 제공한다.

**순수 추상 클래스 특징**

- 인스턴스를 생성할 수 없다.
- 상속시 자식은 모든 메서드를 오버라이딩 해야 한다.
- 주로 다형성을 위해 사용된다.

```java
public interface Car {
    // 상수 정의
    public static final String CAR_TYPE = "T";

    // 인터페이스 메서드
    public abstract void repair();
    public abstract void move();
}
```

- public abstract 키워드 생략 가능

### 인터페이스 특징

- 인터페이스의 메서드는 모두 `public` , `abstract` 이다.
- 메서드에 `public abstract` 를 생략할 수 있다. 참고로 생략이 권장된다.
- 인터페이스는 다중 구현(다중 상속)을 지원한다.
- 인터페이스는 상수 정도는 정의할 수 있다.
  - `public static final` 생략 가능

**클래스, 추상 클래스, 인터페이스는 모두 똑같다.**

- 클래스, 추상 클래스, 인터페이스는 프로그램 코드, 메모리 구조상 모두 똑같다. 모두 자바에서는 `.class` 로 다루어진다. 인터페이스를 작성할 때도 `.java` 에 인터페이스를 정의한다.

#### 인터페이스를 사용해야 하는 이유

- 제약: 인터페이스를 만드는 이유는 인터페이스를 구현하는 곳에서 인터페이스의 메서드를 반드시 구현해라는 규약(제약)을 주는 것이다.
- 다중 구현: 자바에서 클래스 상속은 부모를 하나만 지정할 수 있다. 반면에 인터페이스는 부모를 여러명 두는 다중구현(다중 상속)이 가능하다.

### 인터페이스 - 다중 구현

**자바가 다중 상속을 지원하지 않는 이유**

만약 자식 클래스가 있고, 다중 상속한 두 부모 클래스가 있다고 가정하자.

- 두 부모 클래스는 `move()`라는 메서드를 가지고 있고, 자식 클래스 입장에서는 어느 부모 클래스의 `move()` 메서드를 호출해야할지 모르는 상황이 온다. 하지만 인터페이스의 다중 구현을 허용하여 이러한 문제를 피한다.

![interface](https://github.com/azurealstn/to-be-better-backend-engineer/assets/55525868/8f4b9ef6-b41d-4b89-9548-11599f2f5b69)

`InterfaceA`, `InterfaceB`는 둘다 같은 methodCommon() 을 가지고 있다. 그리고 `Child`는 두 인터페이스를 구현했다.

인터페이스 자체에는 구현을 하지 않는다. 대신 위 그림에서 `Child`는 모든 기능을 구현해야 한다. 여기서 `InterfaceA`, `InterfaceB`는 같은 이름의 `methodCommon()`를 제공하지만 `Child` 입장에서는 그냥 `methodCommon()`를 구현하면 된다. 그리고 `InterfaceA`, `InterfaceB` 각각 원하는 기능들인 `methodA()`, `methodB()`를 구현하면 된다.
